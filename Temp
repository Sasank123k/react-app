package com.wellsfargo.utcap.controller;

import com.wellsfargo.utcap.model.GithubClientProperties;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.IOException;
import java.util.UUID;

/**
 * Controller for GitHub Authentication (OAuth Flow).
 * It provides endpoints for redirecting to GitHub for authentication (/auth)
 * and handling the callback (/callback) after user authorization.
 */
@RestController
@RequestMapping("/ghe")
public class GitAuthController {

    private static final Logger log = LoggerFactory.getLogger(GitAuthController.class);
    private final GithubClientProperties githubClientProperties;

    // Inject GitHub client properties from configuration
    public GitAuthController(GithubClientProperties githubClientProperties) {
        this.githubClientProperties = githubClientProperties;
    }

    /**
     * Redirects the user to GitHub Enterprise's OAuth login page.
     *
     * @param response HttpServletResponse used for redirection
     * @param session  HttpSession to store the generated OAuth state
     * @throws IOException if redirection fails
     */
    @GetMapping("/auth")
    public void redirectToGithub(HttpServletResponse response, HttpSession session) throws IOException {
        // Generate a unique state parameter to prevent CSRF
        String state = UUID.randomUUID().toString();
        session.setAttribute("GITHUB_OAUTH_STATE", state);
        log.info("In /auth: Session ID: {} | State set: '{}'", session.getId(), state);

        // Build the authorization URL with required parameters
        String clientId = githubClientProperties.getId();
        String redirectUri = "http://localhost:8080/ghe/callback";
        String authorizationUrl = "https://github.wellsfargo.com/login/oauth/authorize"
                + "?client_id=" + clientId
                + "&redirect_uri=" + redirectUri
                + "&scope=repo"
                + "&state=" + state;
        response.sendRedirect(authorizationUrl);
    }

    /**
     * Handles the GitHub callback after user authorization.
     * Exchanges the provided code for an access token and stores it in the session.
     *
     * @param code     the code provided by GitHub
     * @param state    the state parameter to validate the request
     * @param session  HttpSession to retrieve and store attributes
     * @param response HttpServletResponse used for redirection or error response
     * @throws IOException if response writing fails
     */
    @GetMapping("/callback")
    public void handleGithubCallback(String code, String state, HttpSession session, HttpServletResponse response) throws IOException {
        log.info("In /callback: Session ID: {}", session.getId());
        String sessionState = (String) session.getAttribute("GITHUB_OAUTH_STATE");
        log.info("In /callback: Stored state: '{}' | Received state: '{}'", sessionState, state);

        // Validate the state parameter
        if (sessionState == null || !sessionState.equals(state)) {
            response.sendError(HttpStatus.UNAUTHORIZED.value(), "Invalid state parameter");
            return;
        }

        // Exchange the authorization code for an access token
        String accessToken = getAccessTokenFromGhe(code);
        log.info("Access Token: {}", accessToken);

        // Store the access token in session for future API calls
        session.setAttribute("GHE_ACCESS_TOKEN", accessToken);
        log.info("before redirect");
        response.addHeader("X-REQUEST-ID", UUID.randomUUID().toString());
        // Note: Explicit cookie setting has been removed per internal requirements

        // Redirect the user to the frontend after successful authentication
        response.sendRedirect("http://localhost:3000/githubintegrationpage");
        log.info("after redirect");
    }

    /**
     * Helper method to exchange the authorization code for an access token.
     *
     * @param code the authorization code received from GitHub
     * @return the access token as a String
     */
    private String getAccessTokenFromGhe(String code) {
        String tokenUrl = "https://github.wellsfargo.com/login/oauth/access_token";
        org.springframework.web.client.RestTemplate restTemplate = new org.springframework.web.client.RestTemplate();

        // Prepare parameters for token exchange
        org.springframework.util.LinkedMultiValueMap<String, String> params = new org.springframework.util.LinkedMultiValueMap<>();
        params.add("client_id", githubClientProperties.getId());
        params.add("client_secret", githubClientProperties.getSecret());
        params.add("code", code);

        // Build headers including required internal headers
        org.springframework.http.HttpHeaders headers = new org.springframework.http.HttpHeaders();
        headers.setContentType(org.springframework.http.MediaType.APPLICATION_FORM_URLENCODED);
        headers.add("X-REQUEST-ID", UUID.randomUUID().toString());
        headers.add("X-CORRELATION-ID", UUID.randomUUID().toString());
        headers.add("X-CLIENT-ID", "UTCAP");

        org.springframework.http.HttpEntity<org.springframework.util.MultiValueMap<String, String>> requestEntity =
                new org.springframework.http.HttpEntity<>(params, headers);

        // Execute the POST request to fetch the access token
        org.springframework.http.ResponseEntity<String> response = restTemplate.exchange(
                tokenUrl, org.springframework.http.HttpMethod.POST, requestEntity, String.class);
        String responseBody = response.getBody();
        log.info("Token endpoint response: {}", responseBody);

        // Parse and return the access token from the response
        return java.util.Arrays.stream(responseBody.split("&"))
                .filter(s -> s.startsWith("access_token"))
                .map(s -> s.split("=")[1])
                .findFirst()
                .orElseThrow(() -> new RuntimeException("No access token found"));
    }
}




package com.wellsfargo.utcap.controller;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import jakarta.servlet.http.HttpSession;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import java.util.Collections;
import java.util.UUID;

/**
 * Controller for fetching GitHub repositories and branches.
 * Provides endpoints to list repositories (with push access) and branches for a specific repository.
 */
@RestController
@RequestMapping("/ghe")
public class RepositoryController {

    private static final Logger log = LoggerFactory.getLogger(RepositoryController.class);
    private static final String GHE_API_BASE = "https://github.wellsfargo.com/api/v3/";

    /**
     * Retrieves the list of repositories where the authenticated user has push access.
     *
     * @param session HttpSession to obtain the stored access token
     * @return ResponseEntity with filtered repository list or error status
     */
    @GetMapping("/repositories")
    public ResponseEntity<?> getRepositories(HttpSession session) {
        String accessToken = (String) session.getAttribute("GHE_ACCESS_TOKEN");
        if (accessToken == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Not authenticated");
        }

        RestTemplate restTemplate = new RestTemplate();
        String url = GHE_API_BASE + "/user/repos";
        HttpHeaders headers = buildAuthHeaders(accessToken);
        HttpEntity<?> entity = new HttpEntity<>(headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
        String responseBody = response.getBody();
        log.info("Repositories API response status: {}", response.getStatusCode());

        ObjectMapper objectMapper = new ObjectMapper();
        try {
            JsonNode rootArray = objectMapper.readTree(responseBody);
            ArrayNode filteredRepos = objectMapper.createArrayNode();
            // Filter repositories where the user has push permissions
            if (rootArray.isArray()) {
                for (JsonNode repoNode : rootArray) {
                    JsonNode permissions = repoNode.get("permissions");
                    if (permissions != null && permissions.get("push").asBoolean()) {
                        ObjectNode simpleRepo = objectMapper.createObjectNode();
                        simpleRepo.put("name", repoNode.get("name").asText());
                        simpleRepo.put("owner", repoNode.get("owner").get("login").asText());
                        filteredRepos.add(simpleRepo);
                    }
                }
            }
            return ResponseEntity.ok(filteredRepos);
        } catch (Exception e) {
            log.error("Error parsing repositories", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error processing repositories");
        }
    }

    /**
     * Retrieves the list of branches for a specified repository.
     *
     * @param owner   the repository owner's username
     * @param repo    the repository name
     * @param session HttpSession to obtain the stored access token
     * @return ResponseEntity with branch names or error status
     */
    @GetMapping("/branches")
    public ResponseEntity<?> getBranches(@RequestParam("owner") String owner,
                                         @RequestParam("repo") String repo,
                                         HttpSession session) {
        String accessToken = (String) session.getAttribute("GHE_ACCESS_TOKEN");
        if (accessToken == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Not authenticated");
        }

        RestTemplate restTemplate = new RestTemplate();
        String url = GHE_API_BASE + "/repos/" + owner + "/" + repo + "/branches";
        HttpHeaders headers = buildAuthHeaders(accessToken);
        HttpEntity<?> entity = new HttpEntity<>(headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
        String responseBody = response.getBody();
        log.info("Branches API response: {}", responseBody);

        ObjectMapper objectMapper = new ObjectMapper();
        try {
            JsonNode root = objectMapper.readTree(responseBody);
            ArrayNode branchNames = objectMapper.createArrayNode();
            // Iterate through the array and add each branch name
            if (root.isArray()) {
                for (JsonNode branch : root) {
                    branchNames.add(branch.get("name").asText());
                }
            }
            return ResponseEntity.ok(branchNames);
        } catch (Exception e) {
            log.error("Error parsing branches", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error processing branches");
        }
    }

    /**
     * Builds and returns HTTP headers with authentication and required internal headers.
     *
     * @param accessToken the GitHub access token
     * @return HttpHeaders including authorization and internal header values
     */
    private HttpHeaders buildAuthHeaders(String accessToken) {
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "token " + accessToken);
        headers.setAccept(Collections.singletonList(MediaType.parseMediaType("application/vnd.github.v3+json")));
        headers.add("X-REQUEST-ID", UUID.randomUUID().toString());
        headers.add("X-CORRELATION-ID", UUID.randomUUID().toString());
        headers.add("X-CLIENT-ID", "UTCAP");
        return headers;
    }
}


package com.wellsfargo.utcap.controller;

import com.wellsfargo.utcap.dto.GitOperationRequest;
import jakarta.servlet.http.HttpSession;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.*;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;

import java.util.Collections;
import java.util.UUID;

/**
 * Controller for handling Git operations.
 * It processes operations like creating a branch, updating a file, adding a file, and merging branches.
 */
@RestController
@RequestMapping("/ghe")
public class GitOperationsController {

    private static final Logger log = LoggerFactory.getLogger(GitOperationsController.class);
    private static final String GHE_API_BASE = "https://github.wellsfargo.com/api/v3/";

    /**
     * Endpoint to perform Git operations based on the operation type specified in the request.
     *
     * @param request GitOperationRequest payload containing details of the Git operation
     * @param session HttpSession to obtain the stored access token
     * @return ResponseEntity with the result of the operation or an error message
     */
    @PostMapping("/operation")
    public ResponseEntity<?> performOperation(@RequestBody GitOperationRequest request, HttpSession session) {
        String accessToken = (String) session.getAttribute("GHE_ACCESS_TOKEN");
        if (accessToken == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Not authenticated");
        }

        try {
            String result;
            // Route the request to the appropriate Git operation based on the operation field
            switch (request.getOperation()) {
                case "createBranch":
                    result = createBranch(accessToken, request);
                    break;
                case "updateFile":
                    result = updateFile(accessToken, request);
                    break;
                case "addFile":
                    result = addFile(accessToken, request);
                    break;
                case "mergeBranch":
                    result = mergeBranch(accessToken, request);
                    break;
                default:
                    return ResponseEntity.badRequest().body("Invalid operation: " + request.getOperation());
            }
            return ResponseEntity.ok(result);
        } catch (Exception ex) {
            log.error("Operation failed", ex);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Operation failed: " + ex.getMessage());
        }
    }

    /**
     * Creates a new branch in the repository.
     *
     * @param accessToken the GitHub access token
     * @param request     details for branch creation (new branch name and base SHA)
     * @return the response from the GitHub API as a String
     */
    private String createBranch(String accessToken, GitOperationRequest request) {
        String url = GHE_API_BASE + "/repos/" + request.getOwner() + "/" + request.getRepo() + "/git/refs";
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders headers = buildAuthHeaders(accessToken);
        headers.setContentType(MediaType.APPLICATION_JSON);
        String payload = String.format("{\"ref\": \"refs/heads/%s\", \"sha\": \"%s\"}",
                request.getNewBranch(), request.getBaseSha());
        HttpEntity<String> entity = new HttpEntity<>(payload, headers);
        ResponseEntity<String> response = restTemplate.postForEntity(url, entity, String.class);
        log.info("Create branch response: {}", response.getBody());
        return response.getBody();
    }

    /**
     * Updates an existing file in the repository.
     *
     * @param accessToken the GitHub access token
     * @param request     details for updating the file including file path, commit message, content, and file SHA
     * @return the response from the GitHub API as a String
     */
    private String updateFile(String accessToken, GitOperationRequest request) {
        String url = GHE_API_BASE + "/repos/" + request.getOwner() + "/" + request.getRepo()
                + "/contents/" + request.getFilePath();
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders headers = buildAuthHeaders(accessToken);
        headers.setContentType(MediaType.APPLICATION_JSON);
        String payload = String.format("{\"message\": \"%s\", \"content\": \"%s\", \"sha\": \"%s\"}",
                request.getCommitMessage(), request.getContent(), request.getFileSha());
        HttpEntity<String> entity = new HttpEntity<>(payload, headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.PUT, entity, String.class);
        log.info("Update file response: {}", response.getBody());
        return response.getBody();
    }

    /**
     * Adds a new file to the repository.
     *
     * @param accessToken the GitHub access token
     * @param request     details for adding the file including file path, commit message, and content
     * @return the response from the GitHub API as a String
     */
    private String addFile(String accessToken, GitOperationRequest request) {
        String url = GHE_API_BASE + "/repos/" + request.getOwner() + "/" + request.getRepo()
                + "/contents/" + request.getFilePath();
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders headers = buildAuthHeaders(accessToken);
        headers.setContentType(MediaType.APPLICATION_JSON);
        String payload = String.format("{\"message\": \"%s\", \"content\": \"%s\"}",
                request.getCommitMessage(), request.getContent());
        HttpEntity<String> entity = new HttpEntity<>(payload, headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.PUT, entity, String.class);
        log.info("Add file response: {}", response.getBody());
        return response.getBody();
    }

    /**
     * Merges two branches in the repository.
     *
     * @param accessToken the GitHub access token
     * @param request     details for merging including base branch, head branch, and commit message
     * @return the response from the GitHub API as a String
     */
    private String mergeBranch(String accessToken, GitOperationRequest request) {
        String url = GHE_API_BASE + "/repos/" + request.getOwner() + "/" + request.getRepo() + "/merges";
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders headers = buildAuthHeaders(accessToken);
        headers.setContentType(MediaType.APPLICATION_JSON);
        String payload = String.format("{\"base\": \"%s\", \"head\": \"%s\", \"commit_message\": \"%s\"}",
                request.getBaseBranch(), request.getHeadBranch(), request.getCommitMessage());
        HttpEntity<String> entity = new HttpEntity<>(payload, headers);
        ResponseEntity<String> response = restTemplate.postForEntity(url, entity, String.class);
        log.info("Merge branch response: {}", response.getBody());
        return response.getBody();
    }

    /**
     * Builds and returns HTTP headers with authorization and internal headers required by Wells Fargo.
     *
     * @param accessToken the GitHub access token
     * @return HttpHeaders with the necessary values set
     */
    private HttpHeaders buildAuthHeaders(String accessToken) {
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "token " + accessToken);
        headers.setAccept(Collections.singletonList(MediaType.parseMediaType("application/vnd.github.v3+json")));
        headers.add("X-REQUEST-ID", UUID.randomUUID().toString());
        headers.add("X-CORRELATION-ID", UUID.randomUUID().toString());
        headers.add("X-CLIENT-ID", "UTCAP");
        return headers;
    }
}

