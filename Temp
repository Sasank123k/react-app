Below are the updated files with the changes to correctly pass the schema definitions and display the remove button for all sub‑jobs. In summary, we now do the following:

1. In **JILEditor.jsx**, we pass the fully resolved main box schema as well as the entire definitions object (from metadata.definitions) down into FieldRenderer. This lets the child job–creation functions reference the standalone definitions (SubBOX, CMD, FW) directly.

2. In **JILFieldRenderer.jsx**, we add a new prop named `definitions` and pass that along to the child editors so that they can use it in their lookup logic.

3. In **JILBoxEditor.jsx** (which handles both main box and sub‑box jobs), the `addChildJob` function now uses the passed `definitions` prop to get the correct default schema for a sub-job. For example, when adding a sub‑box (jobType "BOX"), it now calls:  
   ```js
   const newJob = fillDefaults(definitions.SubBOX);
   ```
   (and likewise for CMD and FW).  
   In addition, the condition to show the remove button is now based on checking if the path length is greater than 1.

4. In **JILCmdEditor.jsx** and **JILFwEditor.jsx**, the remove button condition is updated so that it appears when the job is not top‑level (i.e. if `path.length > 1`).

Below are the complete updated codes for the five files affected:

---

### 1. **JILEditor.jsx**

```jsx
import React, { useState, useEffect, useContext } from "react";
import { JILEditorContext } from "./JILEditorContext";
import JILFieldRenderer from "./JILFieldRenderer";
import { MICROSERVICE_URL } from "../../../util/Constant";
import { generateSearHeader } from "../../../Authenitcation";
import { useAppGlobalState } from "@wf/react-library";
import { convertToJILText } from "./jilUtils";
import "./JILEditor.css";

const JILEditor = ({ requirementId }) => {
  const { jilFiles, currentFileIndex, updateCurrentFile } = useContext(JILEditorContext);
  const [metadata, setMetadata] = useState(null);
  const [rawPreview, setRawPreview] = useState("");
  const { token } = useAppGlobalState();
  const currentFile = jilFiles[currentFileIndex];

  // Fetch JIL metadata.
  useEffect(() => {
    fetch(`${MICROSERVICE_URL}/api/jilMetadata`, {
      method: "GET",
      headers: generateSearHeader(token)
    })
      .then((res) => res.json())
      .then((data) => {
        // Metadata is returned as an array—pick the first element and set metaData from definitions.
        setMetadata(data[0].metaData);
      })
      .catch((err) => {
        console.error("Error fetching metadata:", err);
      });
  }, [token]);

  // Update live preview on current file changes.
  useEffect(() => {
    const previewText = convertToJILText(currentFile);
    setRawPreview(previewText);
  }, [currentFile]);

  const handleSave = () => {
    fetch(`${MICROSERVICE_URL}/api/jilData/${requirementId}`, {
      method: "PUT",
      headers: {
        ...generateSearHeader(token),
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ jilFiles })
    })
      .then((res) => {
        if (!res.ok) {
          throw new Error("Save failed");
        }
        return res.json();
      })
      .then(() => {
        alert("JIL file saved successfully!");
      })
      .catch((err) => {
        console.error("Error saving JIL file:", err);
      });
  };

  if (!metadata) {
    return <div>Loading metadata...</div>;
  }

  return (
    <div className="jil-editor">
      <div className="jil-editor-header">
        <h3>JIL Editor</h3>
        <button onClick={handleSave}>Save</button>
      </div>
      <div className="jil-editor-body">
        <div className="jil-editor-left">
          <h4>Structured Editor</h4>
          {/* Pass the full main box definition and the metadata definitions */}
          <JILFieldRenderer
            schema={metadata.definitions.MainBOX}
            definitions={metadata.definitions}
            data={currentFile.mainBox || {}}
            path={["mainBox"]}
            onFieldChange={(updatedData) => {
              updateCurrentFile({ ...currentFile, mainBox: updatedData });
            }}
          />
        </div>
        <div className="jil-editor-right">
          <h4>Live Preview</h4>
          <textarea readOnly value={rawPreview} />
        </div>
      </div>
    </div>
  );
};

export default JILEditor;
```

---

### 2. **JILFieldRenderer.jsx**

```jsx
import React from "react";
import JILBoxEditor from "./JILBoxEditor";
import JILCmdEditor from "./JILCmdEditor";
import JILFwEditor from "./JILFwEditor";

const JILFieldRenderer = ({ schema, definitions, data, path, onFieldChange, onRemoveJob }) => {
  // If the schema contains "oneOf", use it to pick the child schema.
  if (schema.oneOf) {
    let selectedSchema = schema.oneOf[0];
    if (data.job_type) {
      const found = schema.oneOf.find((s) => {
        if (s.$ref && data.job_type) {
          return s.$ref.includes(data.job_type);
        }
        return false;
      });
      if (found) {
        selectedSchema = found;
      }
    }
    // Render based on job type in the selected schema.
    if (selectedSchema.$ref && selectedSchema.$ref.includes("SubBOX")) {
      return (
        <JILBoxEditor
          schema={selectedSchema}
          definitions={definitions}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    } else if (selectedSchema.$ref && selectedSchema.$ref.includes("CMD")) {
      return (
        <JILCmdEditor
          schema={selectedSchema}
          definitions={definitions}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    } else if (selectedSchema.$ref && selectedSchema.$ref.includes("FW")) {
      return (
        <JILFwEditor
          schema={selectedSchema}
          definitions={definitions}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    } else {
      // Fallback: treat as box job.
      return (
        <JILBoxEditor
          schema={selectedSchema}
          definitions={definitions}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    }
  }

  // Fallback based on data.job_type.
  switch (data.job_type) {
    case "BOX":
      return (
        <JILBoxEditor
          schema={schema}
          definitions={definitions}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    case "CMD":
      return (
        <JILCmdEditor
          schema={schema}
          definitions={definitions}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    case "FW":
      return (
        <JILFwEditor
          schema={schema}
          definitions={definitions}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    default:
      return <div>Unknown job type</div>;
  }
};

export default JILFieldRenderer;
```

---

### 3. **JILBoxEditor.jsx**

```jsx
import React, { useState } from "react";
import JILFieldRenderer from "./JILFieldRenderer";
import { fillDefaults } from "./jilUtils";

const JILBoxEditor = ({ schema, definitions, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  // Update a field value in the current box.
  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  // Remove a key-value pair.
  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  // Render key-value pairs (excluding 'properties').
  const renderKeyValuePairs = () => {
    return Object.keys(data)
      .filter((k) => k !== "properties")
      .map((key, idx) => (
        <div key={idx} className="jil-keyvalue-row">
          <label>{key}: </label>
          <input
            className="jil-input"
            type="text"
            value={data[key]}
            onChange={(e) => handleChange(key, e.target.value)}
          />
          <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
            Remove
          </button>
        </div>
      ));
  };

  // Inline new pair section.
  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  // Update a child job in the "properties" array.
  const handleChildChange = (index, childData) => {
    const newProperties = data.properties ? [...data.properties] : [];
    newProperties[index] = childData;
    handleChange("properties", newProperties);
  };

  // Add a new child job by directly referencing the metadata definitions.
  const addChildJob = (jobType) => {
    let newJob = {};
    if (jobType === "BOX") {
      newJob = fillDefaults(definitions.SubBOX);
    } else if (jobType === "CMD") {
      newJob = fillDefaults(definitions.CMD);
    } else if (jobType === "FW") {
      newJob = fillDefaults(definitions.FW);
    }
    newJob.job_type = jobType;
    if (jobType === "BOX") newJob.properties = [];
    const newProperties = data.properties ? [...data.properties, newJob] : [newJob];
    handleChange("properties", newProperties);
  };

  // Render child jobs.
  const renderChildJobs = () => {
    const children = data.properties || [];
    return children.map((child, index) => (
      <div key={index} className="jil-child-job">
        <JILFieldRenderer
          schema={child.job_type === "BOX" ? definitions.SubBOX : {}}
          definitions={definitions}
          data={child}
          path={[...path, "properties", index]}
          onFieldChange={(childData) => handleChildChange(index, childData)}
          onRemoveJob={() => {
            const newProperties = data.properties.filter((_, idx) => idx !== index);
            handleChange("properties", newProperties);
          }}
        />
      </div>
    ));
  };

  return (
    <div className="jil-box-editor">
      <div className="jil-job-header">
        <span>{path[0] === "mainBox" && path.length === 1 ? "Main Box Job" : "Sub Box"}</span>
        <div className="jil-header-actions">
          {/* Dropdown for adding a child job */}
          <select
            className="jil-job-dropdown"
            onChange={(e) => {
              if (e.target.value) {
                addChildJob(e.target.value);
                e.target.value = "";
              }
            }}
          >
            <option value="">Add Child Job...</option>
            <option value="BOX">Sub Box</option>
            <option value="CMD">CMD</option>
            <option value="FW">FW</option>
          </select>
          {/* Show remove job button if not top-level main box */}
          {path.length > 1 && (
            <button className="jil-remove-job-btn" onClick={() => onRemoveJob && onRemoveJob()}>
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-box-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
      <div className="jil-child-section">
        <h5>Child Jobs</h5>
        {renderChildJobs()}
      </div>
    </div>
  );
};

export default JILBoxEditor;
```

---

### 4. **JILCmdEditor.jsx**

```jsx
import React, { useState } from "react";

const JILCmdEditor = ({ schema, definitions, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  const renderKeyValuePairs = () => {
    return Object.keys(data).map((key, idx) => (
      <div key={idx} className="jil-keyvalue-row">
        <label>{key}: </label>
        <input
          className="jil-input"
          type="text"
          value={data[key]}
          onChange={(e) => handleChange(key, e.target.value)}
        />
        <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
          Remove
        </button>
      </div>
    ));
  };

  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  return (
    <div className="jil-cmd-editor">
      <div className="jil-job-header">
        <span>CMD Job</span>
        <div className="jil-header-actions">
          {path.length > 1 && (
            <button className="jil-remove-job-btn" onClick={() => onRemoveJob && onRemoveJob()}>
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-cmd-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
    </div>
  );
};

export default JILCmdEditor;
```

---

### 5. **JILFwEditor.jsx**

```jsx
import React, { useState } from "react";

const JILFwEditor = ({ schema, definitions, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  const renderKeyValuePairs = () => {
    return Object.keys(data).map((key, idx) => (
      <div key={idx} className="jil-keyvalue-row">
        <label>{key}: </label>
        <input
          className="jil-input"
          type="text"
          value={data[key]}
          onChange={(e) => handleChange(key, e.target.value)}
        />
        <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
          Remove
        </button>
      </div>
    ));
  };

  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  return (
    <div className="jil-fw-editor">
      <div className="jil-job-header">
        <span>File Watcher Job (FW)</span>
        <div className="jil-header-actions">
          {path.length > 1 && (
            <button className="jil-remove-job-btn" onClick={() => onRemoveJob && onRemoveJob()}>
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-fw-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
    </div>
  );
};

export default JILFwEditor;
```

---

### Notes on the Changes

- **Passing Definitions:**  
  In both **JILEditor.jsx** and **JILFieldRenderer.jsx**, the entire `metadata.definitions` object is passed down as a prop (`definitions`) so that child editors can reference the correct schema for new jobs.

- **Child Job Addition in JILBoxEditor.jsx:**  
  The `addChildJob` function now directly uses the passed `definitions`—for example, for a sub‑job (jobType `"BOX"`), it calls:  
  ```js
  newJob = fillDefaults(definitions.SubBOX);
  ```
  This ensures that the new job is created with the default key–value pairs for a SubBOX rather than the MainBOX.

- **Remove Button Condition:**  
  In all editors, the remove button now displays when `path.length > 1` (i.e. for any job that isn’t the top-level main box).

These updates should correctly pass the schema information for child jobs and display the remove button correctly for all sub‑jobs. Let me know if you have any further questions or need additional adjustments!
