Below is one complete, updated example of a modular Properties Editor. This set of files uses the same API endpoints, headers, and auxiliary components (IngressNavigation and DiaasButton) as in your existing code. You can adapt these examples to your project as needed.

---

## 1. PropertiesEditor.jsx

This is the main component. It fetches the properties template and requirement details, stores the data in state, and lets the user edit the raw text (which later you can extend into a key–value row UI if desired). It also uses IngressNavigation and DiaasButton for navigation and actions.

```jsx
// PropertiesEditor.jsx
import React, { useEffect, useState } from "react";
import axios from "axios";
import { useNavigate, useLocation } from "react-router-dom";
import { useAppGlobalState } from "@wf/react-library";
import { MICROSERVICE_URL } from "../../../constant";
import { generateSearchHeader } from "../../../Authentication";
import IngressNavigation from "../../Workflow/IngressNavigation";
import DiaasButton from "../../../components/DiaasButton";
import "./PropertiesEditor.css";
import {
  getPropertiesTemplate,
  getRequirementDetails,
  createCMPPropFile,
} from "./propertiesActions";

export default function PropertiesEditor() {
  const appGlobalState = useAppGlobalState();
  const [fileName, setFileName] = useState("");
  const [propData, setPropData] = useState("");
  const [jiraKey, setJiraKey] = useState("");
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  // formData is derived from jiraKey, propData, and fileName
  const [formData, setFormData] = useState(null);

  const location = useLocation();
  const navigate = useNavigate();

  // Fetch the template and requirement details on component mount.
  useEffect(() => {
    const fetchData = async () => {
      try {
        // 1. Get the default properties template.
        const templateResponse = await getPropertiesTemplate(appGlobalState);
        setPropData(templateResponse.templateObjList[0].json);

        // 2. Get the requirement details using the value passed in location.state.
        const reqResponse = await getRequirementDetails(location.state, appGlobalState);
        setFileName(reqResponse.data[0].tableName);
        setJiraKey(reqResponse.data[0].requirementId);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [location.state, appGlobalState]);

  // Update the composite formData whenever jiraKey, propData, or fileName changes.
  useEffect(() => {
    setFormData({
      requirementId: jiraKey,
      parameters: propData,
      fileName: fileName,
    });
  }, [jiraKey, propData, fileName]);

  // Handler for text changes in the properties textarea.
  const handleChange = (e) => {
    setPropData(e.target.value);
  };

  // Handler for submitting (saving) the properties file.
  const handleSubmit = async () => {
    // Use jiraKey as requirementId.
    const requirement = {
      requirementId: jiraKey,
      parameters: propData,
      fileName: fileName,
    };
    try {
      const response = await createCMPPropFile(requirement, appGlobalState);
      if (response.data.statusCode === 201) {
        alert("Properties File created successfully!");
        navigate("/createdcmpjil", { state: jiraKey });
      } else {
        alert(
          "Error: " +
            response.data.statusCode +
            " Properties File creation failed!"
        );
      }
    } catch (err) {
      console.error(err);
      alert("Error creating properties file: " + err.message);
    }
  };

  if (loading) return <div>Loading...</div>;
  if (error)
    return <div style={{ color: "red" }}>Error: {error.message}</div>;

  return (
    <div className="applicationContainer">
      <IngressNavigation />
      <h5>Properties File Configuration</h5>
      <div className="editor-box">
        <label htmlFor="parameters" className="editor-label">
          Parameters:
        </label>
        <textarea
          id="parameters"
          name="parameters"
          value={propData}
          onChange={handleChange}
          className="editor-textarea"
        />
        <div className="editor-button-container">
          <DiaasButton title="Generate Properties File" handleChange={handleSubmit} />
        </div>
      </div>
    </div>
  );
}
```

---

## 2. KeyValuePair.jsx

If later you choose to split the raw textarea into individual editable rows for each key–value pair, you can use a component like this. (For now, the above editor uses a raw textarea.)

```jsx
// KeyValuePair.jsx
import React from "react";
import PropTypes from "prop-types";
import "./PropertiesEditor.css";

export default function KeyValuePair({ index, pair, onChange, onRemove }) {
  const handleKeyChange = (e) => {
    onChange(index, { ...pair, key: e.target.value });
  };

  const handleValueChange = (e) => {
    onChange(index, { ...pair, value: e.target.value });
  };

  return (
    <div className="pair-row">
      <input
        type="text"
        placeholder="Key"
        value={pair.key}
        onChange={handleKeyChange}
        className="pair-input"
      />
      <span className="colon-separator">:</span>
      <input
        type="text"
        placeholder="Value"
        value={pair.value}
        onChange={handleValueChange}
        className="pair-input"
      />
      <button onClick={() => onRemove(index)} className="remove-button">
        Remove
      </button>
    </div>
  );
}

KeyValuePair.propTypes = {
  index: PropTypes.number.isRequired,
  pair: PropTypes.shape({
    key: PropTypes.string,
    value: PropTypes.string,
  }).isRequired,
  onChange: PropTypes.func.isRequired,
  onRemove: PropTypes.func.isRequired,
};
```

---

## 3. propertiesActions.js

This file centralizes your API calls using axios. It mirrors the endpoints used in your current code.

```js
// propertiesActions.js
import axios from "axios";
import { MICROSERVICE_URL } from "../../../constant";
import { generateSearchHeader } from "../../../Authentication";

// Fetch the properties template
export async function getPropertiesTemplate(appGlobalState) {
  const response = await axios.get(
    `${MICROSERVICE_URL}/api/v1/getPropertiesTemplate/COMPMPROP`,
    {
      headers: generateSearchHeader(appGlobalState),
    }
  );
  if (response.status !== 200) {
    throw new Error(`Failed to fetch properties template: ${response.status}`);
  }
  return response.data;
}

// Fetch requirement details by requirement ID (passed via location.state)
export async function getRequirementDetails(requirementId, appGlobalState) {
  const response = await axios.get(
    `${MICROSERVICE_URL}/api/v1/searchRequirementForReqID/${requirementId}`,
    {
      headers: generateSearchHeader(appGlobalState),
    }
  );
  if (response.status !== 200) {
    throw new Error(
      `Failed to fetch requirement details: ${response.status}`
    );
  }
  return response;
}

// Create (POST) the properties file.
export async function createCMPPropFile(requirement, appGlobalState) {
  const response = await axios.post(
    `${MICROSERVICE_URL}/api/v1/createCMPPropFile`,
    requirement,
    {
      headers: generateSearchHeader(appGlobalState),
    }
  );
  return response;
}
```

---

## 4. propertiesEndpoint.js

This file holds the endpoint strings. (You might not need this if the endpoints are hard-coded in your actions—but it can centralize configuration.)

```js
// propertiesEndpoint.js
export const propertiesEndpoint = {
  GET_TEMPLATE: "/api/v1/getPropertiesTemplate/COMPMPROP", // Template for properties
  GET_REQUIREMENT: "/api/v1/searchRequirementForReqID/",     // Append requirementId
  CREATE_FILE: "/api/v1/createCMPPropFile",                  // Create file endpoint
};
```

---

## 5. PropertiesEditor.css

A simple CSS file for styling your Properties Editor. You can adjust these styles as needed.

```css
/* PropertiesEditor.css */

.applicationContainer {
  max-width: 800px;
  margin: 0 auto;
  padding: 20px;
  font-family: Arial, sans-serif;
}

.editor-box {
  width: 100%;
  margin: 20px auto;
  padding: 20px;
  border: 1px solid #ccc;
  border-radius: 5px;
}

.editor-label {
  display: block;
  margin-bottom: 5px;
  color: #333;
}

.editor-textarea {
  width: 100%;
  height: 400px;
  padding: 10px;
  border: 1px solid #ccc;
  border-radius: 5px;
  box-sizing: border-box;
  resize: vertical;
}

.editor-button-container {
  display: flex;
  justify-content: center;
  margin-top: 20px;
}

/* Styles for KeyValuePair (if used) */
.pair-row {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
}

.pair-input {
  padding: 6px;
  margin-right: 4px;
  flex: 1;
}

.colon-separator {
  margin-right: 4px;
}

.remove-button {
  background-color: #ff4d4f;
  color: white;
  border: none;
  padding: 6px 10px;
  cursor: pointer;
}

.remove-button:hover {
  background-color: #e04343;
}
```

---

## 6. IngressNavigation.jsx (Stub)

Below is a minimal stub for IngressNavigation. In your actual project, this component will have its own logic and styling.

```jsx
// IngressNavigation.jsx
import React from "react";

export default function IngressNavigation() {
  return (
    <nav style={{ padding: "10px", backgroundColor: "#eee" }}>
      <span>Ingress Navigation</span>
    </nav>
  );
}
```

---

## 7. DiaasButton.jsx (Stub)

Below is a minimal version of DiaasButton. Adjust its props and style as needed.

```jsx
// DiaasButton.jsx
import React from "react";
import PropTypes from "prop-types";

export default function DiaasButton({ title, handleChange }) {
  return (
    <button onClick={handleChange} style={{ padding: "10px 20px", fontSize: "16px" }}>
      {title}
    </button>
  );
}

DiaasButton.propTypes = {
  title: PropTypes.string.isRequired,
  handleChange: PropTypes.func.isRequired,
};
```

---

## How It All Fits Together

1. **PropertiesEditor.jsx**  
   - On mount, it calls functions from **propertiesActions.js** to fetch the properties template and requirement details.
   - It stores the fetched data in state and builds a composite object (`formData`).
   - The user can edit the properties in a textarea.
   - Clicking the DiaasButton calls `handleSubmit`, which posts the data using the `createCMPPropFile` API.

2. **propertiesActions.js & propertiesEndpoint.js**  
   - These files centralize the API calls and endpoints.
   - They use axios along with the custom header generator.

3. **IngressNavigation.jsx & DiaasButton.jsx**  
   - These components provide navigation and action button functionality.

4. **PropertiesEditor.css**  
   - Provides a simple layout and style for the editor.

---

This complete set of files should give you a strong starting point to build and refine your Properties Editor. You can later extend this modular design (for example, by replacing the raw textarea with a more granular key–value row approach using KeyValuePair.jsx) as your needs evolve.

Feel free to ask if you need further adjustments or additional details!
