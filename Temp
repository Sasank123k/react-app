Below are the updated full codes for the required files with your changes incorporated. Note that:

• We now import the correct global hook using  
  `import { useAppGlobalState } from "@wf/react-library";`  
  and we extract the token (`const { token } = useAppGlobalState();`) so that it’s used in dependency arrays.

• We now import the header generator as  
  `import { generateSearHeader } from "../../../Authenitcation";`

• The microservice URL is imported from  
  `import { MICROSERVICE_URL } from "../../../util/Constant";`

• When fetching metadata we now assume the returned data is an array and set metadata using the first element (i.e. `setMetadata(data[0].metaData)`).

• In the child‑job addition code (in the BOX editor) we now “drill down” into the parent’s schema to get the child definitions (from the parent’s property named `"properties"`) and use that for constructing a new job with default values via the helper from **jilUtils.js**.

Below are the updated files. (The optional JILKeyValueEditor file is omitted as requested.)

---

### 1. **JILEditorContainer.jsx**

```jsx
import React, { useState, useEffect } from "react";
import JILEditor from "./JILEditor";
import JILNavigation from "./JILNavigation";
import { JILEditorProvider } from "./JILEditorContext";
import { MICROSERVICE_URL } from "../../../util/Constant";
import { generateSearHeader } from "../../../Authenitcation";
import { useAppGlobalState } from "@wf/react-library";
import "./JILEditor.css";

const JILEditorContainer = ({ requirementId }) => {
  const [jilFiles, setJilFiles] = useState([]);
  const [loading, setLoading] = useState(true);
  const [currentFileIndex, setCurrentFileIndex] = useState(0);
  const { token } = useAppGlobalState();

  useEffect(() => {
    fetch(`${MICROSERVICE_URL}/api/jilData/${requirementId}`, {
      method: "GET",
      headers: generateSearHeader(token)
    })
      .then((res) => res.json())
      .then((data) => {
        if (data.jilFiles && data.jilFiles.length > 0) {
          setJilFiles(data.jilFiles);
        } else {
          // If no file is returned, initialize with an empty default structure.
          setJilFiles([{ mainBox: {} }]);
        }
        setLoading(false);
      })
      .catch((err) => {
        console.error("Error fetching JIL data:", err);
        setLoading(false);
      });
  }, [requirementId, token]);

  const addNewFile = () => {
    setJilFiles([...jilFiles, { mainBox: {} }]);
    setCurrentFileIndex(jilFiles.length);
  };

  const updateCurrentFile = (updatedFile) => {
    const newFiles = jilFiles.map((file, index) =>
      index === currentFileIndex ? updatedFile : file
    );
    setJilFiles(newFiles);
  };

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <JILEditorProvider
      value={{ jilFiles, setJilFiles, currentFileIndex, updateCurrentFile }}
    >
      <div className="jil-editor-container">
        <JILNavigation
          currentFileIndex={currentFileIndex}
          setCurrentFileIndex={setCurrentFileIndex}
          totalFiles={jilFiles.length}
          addNewFile={addNewFile}
        />
        <JILEditor requirementId={requirementId} />
      </div>
    </JILEditorProvider>
  );
};

export default JILEditorContainer;
```

---

### 2. **JILNavigation.jsx**

```jsx
import React from "react";

const JILNavigation = ({ currentFileIndex, setCurrentFileIndex, totalFiles, addNewFile }) => {
  return (
    <div className="jil-navigation">
      <button
        onClick={() =>
          setCurrentFileIndex((prev) => Math.max(prev - 1, 0))
        }
        disabled={currentFileIndex === 0}
      >
        &lt; Prev
      </button>
      <span>
        File {currentFileIndex + 1} of {totalFiles}
      </span>
      <button
        onClick={() =>
          setCurrentFileIndex((prev) =>
            Math.min(prev + 1, totalFiles - 1)
          )
        }
        disabled={currentFileIndex === totalFiles - 1}
      >
        Next &gt;
      </button>
      <button onClick={addNewFile}>Add File</button>
    </div>
  );
};

export default JILNavigation;
```

---

### 3. **JILEditor.jsx**

```jsx
import React, { useState, useEffect, useContext } from "react";
import { JILEditorContext } from "./JILEditorContext";
import JILFieldRenderer from "./JILFieldRenderer";
import { MICROSERVICE_URL } from "../../../util/Constant";
import { generateSearHeader } from "../../../Authenitcation";
import { useAppGlobalState } from "@wf/react-library";
import { convertToJILText } from "./jilUtils";
import "./JILEditor.css";

const JILEditor = ({ requirementId }) => {
  const { jilFiles, currentFileIndex, updateCurrentFile } = useContext(JILEditorContext);
  const [metadata, setMetadata] = useState(null);
  const [rawPreview, setRawPreview] = useState("");
  const { token } = useAppGlobalState();
  const currentFile = jilFiles[currentFileIndex];

  // Fetch JIL metadata.
  useEffect(() => {
    fetch(`${MICROSERVICE_URL}/api/jilMetadata`, {
      method: "GET",
      headers: generateSearHeader(token)
    })
      .then((res) => res.json())
      .then((data) => {
        // Assuming metadata comes as an array, we pick the first element.
        setMetadata(data[0].metaData);
      })
      .catch((err) => {
        console.error("Error fetching metadata:", err);
      });
  }, [token]);

  // Update live preview on current file changes.
  useEffect(() => {
    // For now using JSON conversion; later replace with proper JIL format conversion.
    const previewText = convertToJILText(currentFile);
    setRawPreview(previewText);
  }, [currentFile]);

  const handleSave = () => {
    fetch(`${MICROSERVICE_URL}/api/jilData/${requirementId}`, {
      method: "PUT",
      headers: {
        ...generateSearHeader(token),
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ jilFiles })
    })
      .then((res) => {
        if (!res.ok) {
          throw new Error("Save failed");
        }
        return res.json();
      })
      .then(() => {
        alert("JIL file saved successfully!");
      })
      .catch((err) => {
        console.error("Error saving JIL file:", err);
      });
  };

  if (!metadata) {
    return <div>Loading metadata...</div>;
  }

  return (
    <div className="jil-editor">
      <div className="jil-editor-header">
        <h3>JIL Editor</h3>
        <button onClick={handleSave}>Save</button>
      </div>
      <div className="jil-editor-body">
        <div className="jil-editor-left">
          <h4>Structured Editor</h4>
          {/* Render the mainBox of the current file */}
          <JILFieldRenderer
            schema={metadata.properties.mainBox}
            data={currentFile.mainBox || {}}
            path={["mainBox"]}
            onFieldChange={(updatedData) => {
              updateCurrentFile({ ...currentFile, mainBox: updatedData });
            }}
          />
        </div>
        <div className="jil-editor-right">
          <h4>Live Preview</h4>
          <textarea readOnly value={rawPreview} />
        </div>
      </div>
    </div>
  );
};

export default JILEditor;
```

---

### 4. **JILFieldRenderer.jsx**

```jsx
import React from "react";
import JILBoxEditor from "./JILBoxEditor";
import JILCmdEditor from "./JILCmdEditor";
import JILFwEditor from "./JILFwEditor";

const JILFieldRenderer = ({ schema, data, path, onFieldChange, onRemoveJob }) => {
  // If schema has oneOf, choose one based on data.job_type or default to first option.
  if (schema.oneOf) {
    let selectedSchema = schema.oneOf[0];
    if (data.job_type) {
      const found = schema.oneOf.find((s) => {
        if (s.$ref && data.job_type) {
          return s.$ref.includes(data.job_type);
        }
        return false;
      });
      if (found) {
        selectedSchema = found;
      }
    }
    // Render according to job type.
    if (selectedSchema.$ref && selectedSchema.$ref.includes("SubBOX")) {
      return (
        <JILBoxEditor
          schema={selectedSchema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    } else if (selectedSchema.$ref && selectedSchema.$ref.includes("CMD")) {
      return (
        <JILCmdEditor
          schema={selectedSchema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    } else if (selectedSchema.$ref && selectedSchema.$ref.includes("FW")) {
      return (
        <JILFwEditor
          schema={selectedSchema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    } else {
      return (
        <JILBoxEditor
          schema={selectedSchema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    }
  }

  // Fallback based on data.job_type.
  switch (data.job_type) {
    case "BOX":
      return (
        <JILBoxEditor
          schema={schema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    case "CMD":
      return (
        <JILCmdEditor
          schema={schema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    case "FW":
      return (
        <JILFwEditor
          schema={schema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    default:
      return <div>Unknown job type</div>;
  }
};

export default JILFieldRenderer;
```

---

### 5. **JILBoxEditor.jsx**

```jsx
import React, { useState } from "react";
import JILFieldRenderer from "./JILFieldRenderer";
import { fillDefaults } from "./jilUtils";

const JILBoxEditor = ({ schema, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  // Update a field in the current BOX job.
  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  // Remove a key-value pair.
  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  // Render existing key-value pairs (excluding 'properties').
  const renderKeyValuePairs = () => {
    return Object.keys(data)
      .filter((k) => k !== "properties")
      .map((key, idx) => (
        <div key={idx} className="jil-keyvalue-row">
          <label>{key}: </label>
          <input
            className="jil-input"
            type="text"
            value={data[key]}
            onChange={(e) => handleChange(key, e.target.value)}
          />
          <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
            Remove
          </button>
        </div>
      ));
  };

  // Inline add new pair section.
  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  // Update a child job in the properties array.
  const handleChildChange = (index, childData) => {
    const newProperties = data.properties ? [...data.properties] : [];
    newProperties[index] = childData;
    handleChange("properties", newProperties);
  };

  // Add a new child job.
  // We now derive the child schemas from the parent’s schema.
  const addChildJob = (jobType) => {
    // Attempt to retrieve the child job definitions from parent's schema.
    const childSchemas =
      schema.properties &&
      schema.properties["properties"] &&
      schema.properties["properties"].items;
    let newJob = {};
    if (childSchemas && childSchemas.oneOf && Array.isArray(childSchemas.oneOf)) {
      if (jobType === "BOX") {
        newJob =
          fillDefaults(childSchemas.oneOf.find(item => item.$ref && item.$ref.includes("SubBOX")) || {}) || {};
      } else if (jobType === "CMD") {
        newJob =
          fillDefaults(childSchemas.oneOf.find(item => item.$ref && item.$ref.includes("CMD")) || {}) || {};
      } else if (jobType === "FW") {
        newJob =
          fillDefaults(childSchemas.oneOf.find(item => item.$ref && item.$ref.includes("FW")) || {}) || {};
      }
    }
    // Ensure newJob has the job_type set.
    newJob.job_type = jobType;
    if (jobType === "BOX") newJob.properties = [];
    const newProperties = data.properties ? [...data.properties, newJob] : [newJob];
    handleChange("properties", newProperties);
  };

  // Render child jobs.
  const renderChildJobs = () => {
    const children = data.properties || [];
    return children.map((child, index) => (
      <div key={index} className="jil-child-job">
        <JILFieldRenderer
          schema={schema.properties && schema.properties["properties"] ? schema.properties["properties"].items : {}}
          data={child}
          path={[...path, "properties", index]}
          onFieldChange={(childData) => handleChildChange(index, childData)}
          onRemoveJob={() => {
            // Remove child at index.
            const newProperties = data.properties.filter((_, idx) => idx !== index);
            handleChange("properties", newProperties);
          }}
        />
      </div>
    ));
  };

  return (
    <div className="jil-box-editor">
      <div className="jil-job-header">
        <span>{path[0] === "mainBox" ? "Main Box Job" : "Sub Box"}</span>
        <div className="jil-header-actions">
          {/* Dropdown for adding child job */}
          <select
            className="jil-job-dropdown"
            onChange={(e) => {
              if (e.target.value) {
                addChildJob(e.target.value);
                e.target.value = "";
              }
            }}
          >
            <option value="">Add Child Job...</option>
            <option value="BOX">Sub Box</option>
            <option value="CMD">CMD</option>
            <option value="FW">FW</option>
          </select>
          {/* Show remove job button if not main box */}
          {!(path.length === 1 && path[0] === "mainBox") && (
            <button
              className="jil-remove-job-btn"
              onClick={() => onRemoveJob && onRemoveJob()}
            >
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-box-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
      <div className="jil-child-section">
        <h5>Child Jobs</h5>
        {renderChildJobs()}
      </div>
    </div>
  );
};

export default JILBoxEditor;
```

---

### 6. **JILCmdEditor.jsx**

```jsx
import React, { useState } from "react";

const JILCmdEditor = ({ schema, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  const renderKeyValuePairs = () => {
    return Object.keys(data).map((key, idx) => (
      <div key={idx} className="jil-keyvalue-row">
        <label>{key}: </label>
        <input
          className="jil-input"
          type="text"
          value={data[key]}
          onChange={(e) => handleChange(key, e.target.value)}
        />
        <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
          Remove
        </button>
      </div>
    ));
  };

  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  return (
    <div className="jil-cmd-editor">
      <div className="jil-job-header">
        <span>CMD Job</span>
        <div className="jil-header-actions">
          {!(path && path[0] === "mainBox") && (
            <button className="jil-remove-job-btn" onClick={() => onRemoveJob && onRemoveJob()}>
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-cmd-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
    </div>
  );
};

export default JILCmdEditor;
```

---

### 7. **JILFwEditor.jsx**

```jsx
import React, { useState } from "react";

const JILFwEditor = ({ schema, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  const renderKeyValuePairs = () => {
    return Object.keys(data).map((key, idx) => (
      <div key={idx} className="jil-keyvalue-row">
        <label>{key}: </label>
        <input
          className="jil-input"
          type="text"
          value={data[key]}
          onChange={(e) => handleChange(key, e.target.value)}
        />
        <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
          Remove
        </button>
      </div>
    ));
  };

  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  return (
    <div className="jil-fw-editor">
      <div className="jil-job-header">
        <span>File Watcher Job (FW)</span>
        <div className="jil-header-actions">
          {!(path && path[0] === "mainBox") && (
            <button className="jil-remove-job-btn" onClick={() => onRemoveJob && onRemoveJob()}>
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-fw-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
    </div>
  );
};

export default JILFwEditor;
```

---

### 8. **jilUtils.js**

```js
// Converts the internal JSON structure to a JIL text format.
// For now, returns a formatted JSON string.
// Later, implement proper conversion to JIL format.
export const convertToJILText = (jilJson) => {
  return JSON.stringify(jilJson, null, 2);
};

// A helper function to fill defaults based on a given schema.
// This simplified version iterates over the properties of a schema and uses default values if available.
export const fillDefaults = (schema) => {
  const defaults = {};
  if (schema && schema.properties) {
    Object.keys(schema.properties).forEach((key) => {
      const prop = schema.properties[key];
      defaults[key] = prop.default !== undefined ? prop.default : "";
    });
  }
  return defaults;
};
```

---

### 9. **JILEditorContext.jsx**

```jsx
import React, { createContext } from "react";

export const JILEditorContext = createContext();

export const JILEditorProvider = JILEditorContext.Provider;
```

---

### 10. **JILEditor.css**

```css
/* Container & Global Styles */
.jil-editor-container {
  margin: 20px;
  font-family: Arial, sans-serif;
}

.jil-navigation {
  margin-bottom: 10px;
}

.jil-navigation button {
  margin-right: 5px;
}

/* Editor Layout */
.jil-editor {
  display: flex;
  flex-direction: column;
}

.jil-editor-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.jil-editor-body {
  display: flex;
  margin-top: 10px;
}

.jil-editor-left,
.jil-editor-right {
  width: 50%;
  padding: 10px;
}

/* Make the left panel scrollable */
.jil-editor-left {
  max-height: 600px;
  overflow-y: auto;
}

/* Live preview styling */
.jil-editor-right textarea {
  width: 100%;
  height: 400px;
}

/* Job Editor Styles */
.jil-box-editor,
.jil-cmd-editor,
.jil-fw-editor {
  border: 1px solid #ccc;
  padding: 10px;
  margin-bottom: 10px;
}

.jil-job-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #f2f2f2;
  padding: 5px;
  margin-bottom: 10px;
}

.jil-header-actions {
  display: flex;
  align-items: center;
}

.jil-job-dropdown {
  margin-right: 10px;
}

.jil-remove-job-btn {
  background-color: #e57373;
  color: white;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
}

.jil-remove-job-btn:hover {
  background-color: #ef5350;
}

/* Key-Value Row Styles */
.jil-keyvalue-row {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
}

.jil-keyvalue-row label {
  width: 150px;
  font-weight: bold;
}

.jil-input {
  width: 300px; /* increased size */
  padding: 4px;
  margin-right: 10px;
}

.jil-remove-btn {
  background-color: #e57373;
  color: white;
  border: none;
  padding: 2px 6px;
  cursor: pointer;
}

.jil-remove-btn:hover {
  background-color: #ef5350;
}

/* New Pair Inline Section */
.jil-new-pair-row {
  display: flex;
  align-items: center;
  margin-top: 10px;
}

.jil-add-btn {
  background-color: #81c784;
  color: white;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
  margin-left: 10px;
}

.jil-add-btn:hover {
  background-color: #66bb6a;
}

.jil-add-pair-btn {
  background-color: #64b5f6;
  color: white;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
  margin-top: 10px;
}

.jil-add-pair-btn:hover {
  background-color: #42a5f5;
}

/* Child Jobs Section */
.jil-child-job {
  margin-left: 20px;
  margin-top: 10px;
}

.jil-child-section h5 {
  margin-bottom: 5px;
}
```

---

### Final Remarks

• The updated files now use the correct global state hook (`useAppGlobalState`) and header generator (`generateSearHeader`) from the specified paths.  
• API calls now use the token (extracted from global state) in dependency arrays so that we don’t trigger infinite loops.  
• When fetching metadata, we now extract data from the first element of the returned array.  
• In the BOX editor, the “Add Child Job” function now accesses the child definitions from the parent’s schema (from the property named `"properties"`) to determine default values via the helper function `fillDefaults`.  
• All styling and interactive features (scrollable left pane, inline new key–value pairs with remove buttons, job removal button, increased input sizes) have been implemented per your requirements.

You can now integrate these files into your project. Let me know if further adjustments are needed!
