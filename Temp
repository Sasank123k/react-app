package com.wellsfargo.utcap.controller;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.wellsfargo.utcap.dto.GitOperationRequest;
import com.wellsfargo.utcap.model.GithubClientProperties;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.*;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.UUID;

@RestController
@RequestMapping("/ghe")
public class GithubController {

    private static final Logger log = LoggerFactory.getLogger(GithubController.class);
    private static final String GHE_API_BASE = "https://github.wellsfargo.com/api/v3/";

    private final GithubClientProperties githubClientProperties;

    public GithubController(GithubClientProperties githubClientProperties) {
        this.githubClientProperties = githubClientProperties;
    }

    // --- OAuth Endpoints ---
    @GetMapping("/auth")
    public void redirectToGithub(HttpServletResponse response, HttpSession session) throws IOException {
        String state = UUID.randomUUID().toString();
        session.setAttribute("GITHUB_OAUTH_STATE", state);
        log.info("In /auth: Session ID: {} | State set: '{}'", session.getId(), state);

        String clientId = githubClientProperties.getId();
        String redirectUri = "http://localhost:8080/ghe/callback";
        String authorizationUrl = "https://github.wellsfargo.com/login/oauth/authorize"
                + "?client_id=" + clientId
                + "&redirect_uri=" + redirectUri
                + "&scope=repo"
                + "&state=" + state;
        response.sendRedirect(authorizationUrl);
    }

    @GetMapping("/callback")
    public void handleGithubCallback(
            @RequestParam("code") String code,
            @RequestParam("state") String state,
            HttpSession session,
            HttpServletResponse response) throws IOException {

        log.info("In /callback: Session ID: {}", session.getId());
        String sessionState = (String) session.getAttribute("GITHUB_OAUTH_STATE");
        log.info("In /callback: Stored state: '{}' | Received state: '{}'", sessionState, state);

        if (sessionState == null || !sessionState.equals(state)) {
            response.sendError(HttpStatus.UNAUTHORIZED.value(), "Invalid state parameter");
            return;
        }

        String accessToken = getAccessTokenFromGhe(code);
        log.info("Access Token: {}", accessToken);

        session.setAttribute("GHE_ACCESS_TOKEN", accessToken);
        log.info("before redirect");
        response.addHeader("X-REQUEST-ID", UUID.randomUUID().toString());
        Cookie sessionCookie = new Cookie("JSESSIONID", session.getId());
        sessionCookie.setPath("/");
        sessionCookie.setHttpOnly(true);
        response.addCookie(sessionCookie);
        response.sendRedirect("http://localhost:3000/githubintegrationpage");
        log.info("after redirect");
    }

    private String getAccessTokenFromGhe(String code) {
        String tokenUrl = "https://github.wellsfargo.com/login/oauth/access_token";
        RestTemplate restTemplate = new RestTemplate();
        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("client_id", githubClientProperties.getId());
        params.add("client_secret", githubClientProperties.getSecret());
        params.add("code", code);
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
        headers.add("X-REQUEST-ID", UUID.randomUUID().toString());
        headers.add("X-CORRELATION-ID", UUID.randomUUID().toString());
        headers.add("X-CLIENT-ID", "UTCAP");
        HttpEntity<MultiValueMap<String, String>> requestEntity = new HttpEntity<>(params, headers);
        ResponseEntity<String> response = restTemplate.exchange(tokenUrl, HttpMethod.POST, requestEntity, String.class);
        String responseBody = response.getBody();
        log.info("Token endpoint response: {}", responseBody);
        return Arrays.stream(responseBody.split("&"))
                .filter(s -> s.startsWith("access_token"))
                .map(s -> s.split("=")[1])
                .findFirst()
                .orElseThrow(() -> new RuntimeException("No access token found"));
    }

    // --- API Endpoints for Repositories and Branches ---
    @GetMapping("/repositories")
    public ResponseEntity<?> getRepositories(HttpSession session) {
        String accessToken = (String) session.getAttribute("GHE_ACCESS_TOKEN");
        if (accessToken == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Not authenticated");
        }
        RestTemplate restTemplate = new RestTemplate();
        String url = GHE_API_BASE + "/user/repos";
        HttpHeaders headers = buildAuthHeaders(accessToken);
        HttpEntity<?> entity = new HttpEntity<>(headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
        String responseBody = response.getBody();
        log.info("Repositories API response status: {}", response.getStatusCode());
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            JsonNode rootArray = objectMapper.readTree(responseBody);
            com.fasterxml.jackson.databind.node.ArrayNode filteredRepos = objectMapper.createArrayNode();
            if (rootArray.isArray()) {
                for (JsonNode repoNode : rootArray) {
                    JsonNode permissions = repoNode.get("permissions");
                    if (permissions != null && permissions.get("push").asBoolean()) {
                        ObjectNode simpleRepo = objectMapper.createObjectNode();
                        simpleRepo.put("name", repoNode.get("name").asText());
                        simpleRepo.put("owner", repoNode.get("owner").get("login").asText());
                        filteredRepos.add(simpleRepo);
                    }
                }
            }
            return ResponseEntity.ok(filteredRepos);
        } catch (Exception e) {
            log.error("Error parsing repositories", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error processing repositories");
        }
    }

    @GetMapping("/branches")
    public ResponseEntity<?> getBranches(@RequestParam("owner") String owner,
                                         @RequestParam("repo") String repo,
                                         HttpSession session) {
        String accessToken = (String) session.getAttribute("GHE_ACCESS_TOKEN");
        if (accessToken == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Not authenticated");
        }
        RestTemplate restTemplate = new RestTemplate();
        String url = GHE_API_BASE + "/repos/" + owner + "/" + repo + "/branches";
        HttpHeaders headers = buildAuthHeaders(accessToken);
        HttpEntity<?> entity = new HttpEntity<>(headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
        String responseBody = response.getBody();
        log.info("Branches API response: {}", responseBody);
        ObjectMapper objectMapper = new ObjectMapper();
        try {
            JsonNode root = objectMapper.readTree(responseBody);
            com.fasterxml.jackson.databind.node.ArrayNode branchNames = objectMapper.createArrayNode();
            if (root.isArray()) {
                for (JsonNode branch : root) {
                    branchNames.add(branch.get("name").asText());
                }
            }
            return ResponseEntity.ok(branchNames);
        } catch (Exception e) {
            log.error("Error parsing branches", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error processing branches");
        }
    }

    // --- API Endpoint for Git Operations ---
    @PostMapping("/operation")
    public ResponseEntity<?> performOperation(@RequestBody GitOperationRequest request, HttpSession session) {
        String accessToken = (String) session.getAttribute("GHE_ACCESS_TOKEN");
        if (accessToken == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Not authenticated");
        }
        try {
            String result;
            switch (request.getOperation()) {
                case "createBranch":
                    result = createBranch(accessToken, request);
                    break;
                case "updateFile":
                    result = updateFile(accessToken, request);
                    break;
                case "addFile":
                    result = addFile(accessToken, request);
                    break;
                case "mergeBranch":
                    result = mergeBranch(accessToken, request);
                    break;
                default:
                    return ResponseEntity.badRequest().body("Invalid operation: " + request.getOperation());
            }
            return ResponseEntity.ok(result);
        } catch (Exception ex) {
            log.error("Operation failed", ex);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Operation failed: " + ex.getMessage());
        }
    }

    // --- Helper Methods for Git Operations ---
    // Updated createBranch method: if baseSha is missing, fetch it using baseBranch
    private String createBranch(String accessToken, GitOperationRequest request) {
        String baseSha = request.getBaseSha();
        if (baseSha == null || baseSha.isEmpty()) {
            String branchUrl = GHE_API_BASE + "/repos/" + request.getOwner() + "/" + request.getRepo() 
                    + "/branches/" + request.getBaseBranch();
            RestTemplate restTemplate = new RestTemplate();
            HttpHeaders headers = buildAuthHeaders(accessToken);
            HttpEntity<?> entity = new HttpEntity<>(headers);
            ResponseEntity<String> branchResponse = restTemplate.exchange(branchUrl, HttpMethod.GET, entity, String.class);
            ObjectMapper objectMapper = new ObjectMapper();
            try {
                JsonNode branchNode = objectMapper.readTree(branchResponse.getBody());
                baseSha = branchNode.get("commit").get("sha").asText();
            } catch (Exception e) {
                throw new RuntimeException("Failed to retrieve base branch commit SHA", e);
            }
        }
        String url = GHE_API_BASE + "/repos/" + request.getOwner() + "/" + request.getRepo() + "/git/refs";
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders headers = buildAuthHeaders(accessToken);
        headers.setContentType(MediaType.APPLICATION_JSON);
        String payload = String.format("{\"ref\": \"refs/heads/%s\", \"sha\": \"%s\"}",
                request.getNewBranch(), baseSha);
        HttpEntity<String> entity = new HttpEntity<>(payload, headers);
        ResponseEntity<String> response = restTemplate.postForEntity(url, entity, String.class);
        log.info("Create branch response: {}", response.getBody());
        return response.getBody();
    }

    private String updateFile(String accessToken, GitOperationRequest request) {
        String url = GHE_API_BASE + "/repos/" + request.getOwner() + "/" + request.getRepo()
                + "/contents/" + request.getFilePath();
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders headers = buildAuthHeaders(accessToken);
        headers.setContentType(MediaType.APPLICATION_JSON);
        String payload = String.format("{\"message\": \"%s\", \"content\": \"%s\", \"sha\": \"%s\"}",
                request.getCommitMessage(), request.getContent(), request.getFileSha());
        HttpEntity<String> entity = new HttpEntity<>(payload, headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.PUT, entity, String.class);
        log.info("Update file response: {}", response.getBody());
        return response.getBody();
    }

    private String addFile(String accessToken, GitOperationRequest request) {
        String url = GHE_API_BASE + "/repos/" + request.getOwner() + "/" + request.getRepo()
                + "/contents/" + request.getFilePath();
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders headers = buildAuthHeaders(accessToken);
        headers.setContentType(MediaType.APPLICATION_JSON);
        String payload = String.format("{\"message\": \"%s\", \"content\": \"%s\"}",
                request.getCommitMessage(), request.getContent());
        HttpEntity<String> entity = new HttpEntity<>(payload, headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.PUT, entity, String.class);
        log.info("Add file response: {}", response.getBody());
        return response.getBody();
    }

    private String mergeBranch(String accessToken, GitOperationRequest request) {
        String url = GHE_API_BASE + "/repos/" + request.getOwner() + "/" + request.getRepo() + "/merges";
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders headers = buildAuthHeaders(accessToken);
        headers.setContentType(MediaType.APPLICATION_JSON);
        String payload = String.format("{\"base\": \"%s\", \"head\": \"%s\", \"commit_message\": \"%s\"}",
                request.getBaseBranch(), request.getHeadBranch(), request.getCommitMessage());
        HttpEntity<String> entity = new HttpEntity<>(payload, headers);
        ResponseEntity<String> response = restTemplate.postForEntity(url, entity, String.class);
        log.info("Merge branch response: {}", response.getBody());
        return response.getBody();
    }

    /**
     * Utility method to build HTTP headers for GitHub API requests.
     */
    private HttpHeaders buildAuthHeaders(String accessToken) {
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "token " + accessToken);
        headers.setAccept(Collections.singletonList(MediaType.parseMediaType("application/vnd.github.v3+json")));
        headers.add("X-REQUEST-ID", UUID.randomUUID().toString());
        headers.add("X-CORRELATION-ID", UUID.randomUUID().toString());
        headers.add("X-CLIENT-ID", "UTCAP");
        return headers;
    }
}

import React, { useState } from 'react';
import axios from 'axios';

// Updated import paths based on your project structure
import { generateSearHeader } from '../../../Authentication';
import { useAppGlobalState } from '@wf/react-library';
import MICROSERVICE_URL from '../../../util/constant';

const NewBranchCreator = () => {
  const [owner, setOwner] = useState('');
  const [repo, setRepo] = useState('');
  const [baseBranch, setBaseBranch] = useState('');
  const [newBranch, setNewBranch] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);

  const appGlobalState = useAppGlobalState();

  const handleCreateBranch = async () => {
    setError(null);
    setSuccess(null);
    setLoading(true);

    if (!owner || !repo || !baseBranch || !newBranch) {
      setError('Please fill in all fields.');
      setLoading(false);
      return;
    }

    try {
      const payload = {
        operation: 'createBranch',
        owner: owner,
        repo: repo,
        newBranch: newBranch,
        // Leave baseSha empty so that the backend uses baseBranch to retrieve it.
        baseSha: "",
        baseBranch: baseBranch
      };

      const response = await axios.post(`${MICROSERVICE_URL}/ghe/operation`, payload, {
        headers: generateSearHeader(appGlobalState),
        withCredentials: true,
      });

      setSuccess(`New branch '${newBranch}' created from base branch '${baseBranch}'.`);
    } catch (err) {
      setError(`Error creating branch: ${err.response ? err.response.data : err.message}`);
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="new-branch-creator">
      <h2>Create a New Branch</h2>
      {error && <div className="error">{error}</div>}
      {success && <div className="success">{success}</div>}
      <div className="form-group">
        <label>Owner Name:</label>
        <input
          type="text"
          value={owner}
          onChange={(e) => setOwner(e.target.value)}
          placeholder="Enter owner name"
        />
      </div>
      <div className="form-group">
        <label>Repository Name:</label>
        <input
          type="text"
          value={repo}
          onChange={(e) => setRepo(e.target.value)}
          placeholder="Enter repository name"
        />
      </div>
      <div className="form-group">
        <label>Base Branch:</label>
        <input
          type="text"
          value={baseBranch}
          onChange={(e) => setBaseBranch(e.target.value)}
          placeholder="Enter existing branch name"
        />
      </div>
      <div className="form-group">
        <label>New Branch Name:</label>
        <input
          type="text"
          value={newBranch}
          onChange={(e) => setNewBranch(e.target.value)}
          placeholder="Enter new branch name"
        />
      </div>
      <button onClick={handleCreateBranch} disabled={loading}>
        {loading ? 'Creating...' : 'Create Branch'}
      </button>
    </div>
  );
};

export default NewBranchCreator;
