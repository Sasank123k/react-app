Below is a complete set of files (using the .jsx extension for React components) plus one CSS file. This implementation assumes the same utilities (e.g. MICROSERVICE_URL, generateSearchHeader, useGlobalState) are available as in your JSON editor. For now, the live preview simply shows the JSON structure (with a placeholder conversion function), and all “add new pair” actions use a simple prompt. You can later refine these UIs further.

---

### File: **JILEditorContainer.jsx**

```jsx
import React, { useState, useEffect } from "react";
import JILEditor from "./JILEditor";
import JILNavigation from "./JILNavigation";
import { JILEditorProvider } from "./JILEditorContext";
import { MICROSERVICE_URL } from "../util/constant";
import generateSearchHeader from "../util/Authentication";
import { useGlobalState } from "../react-library";
import "./JILEditor.css";

const JILEditorContainer = ({ requirementId }) => {
  // For now, we assume EDL flow with one JIL file by default.
  const [jilFiles, setJilFiles] = useState([]);
  const [loading, setLoading] = useState(true);
  const [currentFileIndex, setCurrentFileIndex] = useState(0);
  const globalState = useGlobalState();

  useEffect(() => {
    fetch(`${MICROSERVICE_URL}/api/jilData/${requirementId}`, {
      method: "GET",
      headers: generateSearchHeader(globalState)
    })
      .then((res) => res.json())
      .then((data) => {
        if (data.jilFiles && data.jilFiles.length > 0) {
          setJilFiles(data.jilFiles);
        } else {
          // If no file is returned, initialize with an empty default structure.
          setJilFiles([{ mainBox: {} }]);
        }
        setLoading(false);
      })
      .catch((err) => {
        console.error("Error fetching JIL data:", err);
        setLoading(false);
      });
  }, [requirementId, globalState]);

  const addNewFile = () => {
    setJilFiles([...jilFiles, { mainBox: {} }]);
    setCurrentFileIndex(jilFiles.length);
  };

  const updateCurrentFile = (updatedFile) => {
    const newFiles = jilFiles.map((file, index) =>
      index === currentFileIndex ? updatedFile : file
    );
    setJilFiles(newFiles);
  };

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <JILEditorProvider
      value={{ jilFiles, setJilFiles, currentFileIndex, updateCurrentFile }}
    >
      <div className="jil-editor-container">
        <JILNavigation
          currentFileIndex={currentFileIndex}
          setCurrentFileIndex={setCurrentFileIndex}
          totalFiles={jilFiles.length}
          addNewFile={addNewFile}
        />
        <JILEditor requirementId={requirementId} />
      </div>
    </JILEditorProvider>
  );
};

export default JILEditorContainer;
```

---

### File: **JILNavigation.jsx**

```jsx
import React from "react";

const JILNavigation = ({ currentFileIndex, setCurrentFileIndex, totalFiles, addNewFile }) => {
  return (
    <div className="jil-navigation">
      <button
        onClick={() =>
          setCurrentFileIndex((prev) => Math.max(prev - 1, 0))
        }
        disabled={currentFileIndex === 0}
      >
        &lt; Prev
      </button>
      <span>
        File {currentFileIndex + 1} of {totalFiles}
      </span>
      <button
        onClick={() =>
          setCurrentFileIndex((prev) =>
            Math.min(prev + 1, totalFiles - 1)
          )
        }
        disabled={currentFileIndex === totalFiles - 1}
      >
        Next &gt;
      </button>
      <button onClick={addNewFile}>Add File</button>
    </div>
  );
};

export default JILNavigation;
```

---

### File: **JILEditor.jsx**

```jsx
import React, { useState, useEffect, useContext } from "react";
import { JILEditorContext } from "./JILEditorContext";
import JILFieldRenderer from "./JILFieldRenderer";
import { MICROSERVICE_URL } from "../util/constant";
import generateSearchHeader from "../util/Authentication";
import { useGlobalState } from "../react-library";
import { convertToJILText } from "./jilUtils";
import "./JILEditor.css";

const JILEditor = ({ requirementId }) => {
  const { jilFiles, currentFileIndex, updateCurrentFile } = useContext(JILEditorContext);
  const [metadata, setMetadata] = useState(null);
  const [rawPreview, setRawPreview] = useState("");
  const globalState = useGlobalState();
  const currentFile = jilFiles[currentFileIndex];

  // Fetch JIL metadata.
  useEffect(() => {
    fetch(`${MICROSERVICE_URL}/api/jilMetadata`, {
      method: "GET",
      headers: generateSearchHeader(globalState)
    })
      .then((res) => res.json())
      .then((data) => {
        setMetadata(data.metaData);
      })
      .catch((err) => {
        console.error("Error fetching metadata:", err);
      });
  }, [globalState]);

  // Update live preview on current file changes.
  useEffect(() => {
    // For now, using JSON conversion. Later replace with convertToJILText(currentFile).
    const previewText = convertToJILText(currentFile);
    setRawPreview(previewText);
  }, [currentFile]);

  const handleSave = () => {
    fetch(`${MICROSERVICE_URL}/api/jilData/${requirementId}`, {
      method: "PUT",
      headers: {
        ...generateSearchHeader(globalState),
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ jilFiles })
    })
      .then((res) => {
        if (!res.ok) {
          throw new Error("Save failed");
        }
        return res.json();
      })
      .then(() => {
        alert("JIL file saved successfully!");
      })
      .catch((err) => {
        console.error("Error saving JIL file:", err);
      });
  };

  if (!metadata) {
    return <div>Loading metadata...</div>;
  }

  return (
    <div className="jil-editor">
      <div className="jil-editor-header">
        <h3>JIL Editor</h3>
        <button onClick={handleSave}>Save</button>
      </div>
      <div className="jil-editor-body">
        <div className="jil-editor-left">
          <h4>Structured Editor</h4>
          {/* Render the mainBox of the current file */}
          <JILFieldRenderer
            schema={metadata.properties.mainBox}
            data={currentFile.mainBox || {}}
            path={["mainBox"]}
            onFieldChange={(updatedData) => {
              updateCurrentFile({ ...currentFile, mainBox: updatedData });
            }}
          />
        </div>
        <div className="jil-editor-right">
          <h4>Live Preview</h4>
          <textarea readOnly value={rawPreview} />
        </div>
      </div>
    </div>
  );
};

export default JILEditor;
```

---

### File: **JILFieldRenderer.jsx**

```jsx
import React from "react";
import JILBoxEditor from "./JILBoxEditor";
import JILCmdEditor from "./JILCmdEditor";
import JILFwEditor from "./JILFwEditor";

const JILFieldRenderer = ({ schema, data, path, onFieldChange }) => {
  // If schema has oneOf, choose one based on data.job_type or default to first option.
  if (schema.oneOf) {
    let selectedSchema = schema.oneOf[0];
    if (data.job_type) {
      const found = schema.oneOf.find((s) => {
        // Check if the schema reference includes the job type (SubBOX, CMD, FW)
        if (s.$ref && data.job_type) {
          return s.$ref.includes(data.job_type);
        }
        return false;
      });
      if (found) {
        selectedSchema = found;
      }
    }
    // Render according to job type.
    if (selectedSchema.$ref && selectedSchema.$ref.includes("SubBOX")) {
      return (
        <JILBoxEditor
          schema={selectedSchema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
        />
      );
    } else if (selectedSchema.$ref && selectedSchema.$ref.includes("CMD")) {
      return (
        <JILCmdEditor
          schema={selectedSchema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
        />
      );
    } else if (selectedSchema.$ref && selectedSchema.$ref.includes("FW")) {
      return (
        <JILFwEditor
          schema={selectedSchema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
        />
      );
    } else {
      // Fallback to box editor.
      return (
        <JILBoxEditor
          schema={selectedSchema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
        />
      );
    }
  }

  // If no oneOf, fall back on data.job_type.
  switch (data.job_type) {
    case "BOX":
      return (
        <JILBoxEditor
          schema={schema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
        />
      );
    case "CMD":
      return (
        <JILCmdEditor
          schema={schema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
        />
      );
    case "FW":
      return (
        <JILFwEditor
          schema={schema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
        />
      );
    default:
      return <div>Unknown job type</div>;
  }
};

export default JILFieldRenderer;
```

---

### File: **JILBoxEditor.jsx**

```jsx
import React from "react";
import JILFieldRenderer from "./JILFieldRenderer";

const JILBoxEditor = ({ schema, data, path, onFieldChange }) => {
  // Update a field in the current BOX job.
  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  // Update a child job in the properties array.
  const handleChildChange = (index, childData) => {
    const newProperties = data.properties ? [...data.properties] : [];
    newProperties[index] = childData;
    handleChange("properties", newProperties);
  };

  const addChildJob = (jobType) => {
    let newJob;
    if (jobType === "BOX") {
      newJob = { job_type: "BOX", properties: [] };
    } else if (jobType === "CMD") {
      newJob = { job_type: "CMD" };
    } else if (jobType === "FW") {
      newJob = { job_type: "FW" };
    }
    const newProperties = data.properties ? [...data.properties, newJob] : [newJob];
    handleChange("properties", newProperties);
  };

  const addNewPair = () => {
    const key = prompt("Enter new key:");
    if (!key) return;
    const value = prompt("Enter value for " + key + ":");
    handleChange(key, value);
  };

  const renderKeyValuePairs = () => {
    return Object.keys(data)
      .filter((k) => k !== "properties")
      .map((key, idx) => (
        <div key={idx} className="jil-keyvalue-row">
          <label>{key}: </label>
          <input
            type="text"
            value={data[key]}
            onChange={(e) => handleChange(key, e.target.value)}
          />
        </div>
      ));
  };

  const renderChildJobs = () => {
    const children = data.properties || [];
    return children.map((child, index) => (
      <div key={index} className="jil-child-job">
        <JILFieldRenderer
          schema={schema.items ? schema.items : {}}
          data={child}
          path={[...path, "properties", index]}
          onFieldChange={(childData) => handleChildChange(index, childData)}
        />
      </div>
    ));
  };

  return (
    <div className="jil-box-editor">
      <div className="jil-box-header">
        <span>{data.job_type === "BOX" ? "Box Job" : "Sub Box"}</span>
        <button onClick={addNewPair}>Add New Pair</button>
      </div>
      <div className="jil-box-content">{renderKeyValuePairs()}</div>
      <div className="jil-child-section">
        <h5>Child Jobs</h5>
        {renderChildJobs()}
        <div className="jil-add-child">
          <select
            onChange={(e) => {
              if (e.target.value) {
                addChildJob(e.target.value);
                e.target.value = "";
              }
            }}
          >
            <option value="">Add Child Job...</option>
            <option value="BOX">Sub Box</option>
            <option value="CMD">CMD</option>
            <option value="FW">FW</option>
          </select>
        </div>
      </div>
    </div>
  );
};

export default JILBoxEditor;
```

---

### File: **JILCmdEditor.jsx**

```jsx
import React from "react";

const JILCmdEditor = ({ schema, data, path, onFieldChange }) => {
  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const addNewPair = () => {
    const key = prompt("Enter new key:");
    if (!key) return;
    const value = prompt("Enter value for " + key + ":");
    handleChange(key, value);
  };

  const renderKeyValuePairs = () => {
    return Object.keys(data).map((key, idx) => (
      <div key={idx} className="jil-keyvalue-row">
        <label>{key}: </label>
        <input
          type="text"
          value={data[key]}
          onChange={(e) => handleChange(key, e.target.value)}
        />
      </div>
    ));
  };

  return (
    <div className="jil-cmd-editor">
      <div className="jil-cmd-header">
        <span>CMD Job</span>
        <button onClick={addNewPair}>Add New Pair</button>
      </div>
      <div className="jil-cmd-content">{renderKeyValuePairs()}</div>
    </div>
  );
};

export default JILCmdEditor;
```

---

### File: **JILFwEditor.jsx**

```jsx
import React from "react";

const JILFwEditor = ({ schema, data, path, onFieldChange }) => {
  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const addNewPair = () => {
    const key = prompt("Enter new key:");
    if (!key) return;
    const value = prompt("Enter value for " + key + ":");
    handleChange(key, value);
  };

  const renderKeyValuePairs = () => {
    return Object.keys(data).map((key, idx) => (
      <div key={idx} className="jil-keyvalue-row">
        <label>{key}: </label>
        <input
          type="text"
          value={data[key]}
          onChange={(e) => handleChange(key, e.target.value)}
        />
      </div>
    ));
  };

  return (
    <div className="jil-fw-editor">
      <div className="jil-fw-header">
        <span>File Watcher Job (FW)</span>
        <button onClick={addNewPair}>Add New Pair</button>
      </div>
      <div className="jil-fw-content">{renderKeyValuePairs()}</div>
    </div>
  );
};

export default JILFwEditor;
```

---

### File: **JILKeyValueEditor.jsx** *(Optional)*

```jsx
import React from "react";

const JILKeyValueEditor = ({ label, value, onChange }) => {
  return (
    <div className="jil-keyvalue-editor">
      <label>{label}: </label>
      <input type="text" value={value} onChange={(e) => onChange(e.target.value)} />
    </div>
  );
};

export default JILKeyValueEditor;
```

---

### File: **jilUtils.js**

```js
export const convertToJILText = (jilJson) => {
  // Placeholder conversion: currently returns JSON formatted string.
  // Later, implement conversion logic to transform the JSON structure into proper JIL text format.
  return JSON.stringify(jilJson, null, 2);
};
```

---

### File: **JILEditorContext.jsx**

```jsx
import React, { createContext } from "react";

export const JILEditorContext = createContext();

export const JILEditorProvider = JILEditorContext.Provider;
```

---

### File: **JILEditor.css**

```css
.jil-editor-container {
  margin: 20px;
  font-family: Arial, sans-serif;
}

.jil-navigation {
  margin-bottom: 10px;
}

.jil-navigation button {
  margin-right: 5px;
}

.jil-editor {
  display: flex;
  flex-direction: column;
}

.jil-editor-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.jil-editor-body {
  display: flex;
  margin-top: 10px;
}

.jil-editor-left,
.jil-editor-right {
  width: 50%;
  padding: 10px;
}

.jil-editor-right textarea {
  width: 100%;
  height: 400px;
}

.jil-box-editor,
.jil-cmd-editor,
.jil-fw-editor {
  border: 1px solid #ccc;
  padding: 10px;
  margin-bottom: 10px;
}

.jil-box-header,
.jil-cmd-header,
.jil-fw-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #f2f2f2;
  padding: 5px;
}

.jil-keyvalue-row {
  display: flex;
  margin-bottom: 5px;
}

.jil-keyvalue-row label {
  width: 150px;
  font-weight: bold;
}

.jil-keyvalue-row input {
  flex: 1;
}

.jil-child-job {
  margin-left: 20px;
  margin-top: 10px;
}

.jil-add-child {
  margin-top: 10px;
}
```

---

### Final Notes

- The **JILEditorContainer.jsx** fetches the JIL file data and provides context for all nested editors.
- The **JILEditor.jsx** component fetches metadata from `/api/jilMetadata` and renders the structured editor (left) and live preview (right).  
- The **JILFieldRenderer.jsx** dispatches rendering to **JILBoxEditor.jsx**, **JILCmdEditor.jsx**, or **JILFwEditor.jsx** based on the job type.
- In each job editor (BOX, CMD, FW), users can update fields and add new custom key–value pairs via a prompt.
- The live preview currently shows the JSON string; later you can enhance the `convertToJILText` function to output the proper JIL format.
- All components mirror the style and integration patterns used in your JSON editor.

Feel free to adjust and extend these files as needed for further functionality and refinement.
