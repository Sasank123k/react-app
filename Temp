Below is a complete, updated example of a modular Properties Editor that meets your requirements. In this version, we:

- Fetch a default properties template and requirement details from your backend (using your headers and endpoints).
- Convert the default properties (a raw string) into an array of key–value pairs.
- Render each key–value pair in its own row (using a separate component).
- Provide a live preview pane on the right.
- Use your auxiliary components (IngressNavigation and DiaasButton).

You can adjust the code and endpoints as needed.

---

### 1. **PropertiesEditor.jsx**

```jsx
// PropertiesEditor.jsx
import React, { useEffect, useState } from "react";
import axios from "axios";
import { useNavigate, useLocation } from "react-router-dom";
import { useAppGlobalState } from "@wf/react-library";
import { MICROSERVICE_URL } from "../../../constant";
import { generateSearchHeader } from "../../../Authentication";
import IngressNavigation from "../../Workflow/IngressNavigation";
import DiaasButton from "../../../components/DiaasButton";
import "./PropertiesEditor.css";
import {
  getPropertiesTemplate,
  getRequirementDetails,
  createCMPPropFile,
} from "./propertiesActions";
import KeyValuePair from "./KeyValuePair";

// Helper to parse a raw properties string into an array of key-value objects.
function parsePropertiesString(str) {
  if (!str) return [];
  const lines = str.split("\n");
  const pairs = lines.map(line => {
    const colonIndex = line.indexOf(":");
    if (colonIndex !== -1) {
      const key = line.slice(0, colonIndex).trim();
      const value = line.slice(colonIndex + 1).trim();
      return { key, value };
    } else {
      return { key: line.trim(), value: "" };
    }
  });
  return pairs;
}

// Helper to convert an array of key-value pairs back to a string.
function propertiesArrayToString(pairs) {
  return pairs.map(pair => `${pair.key}: ${pair.value}`).join("\n");
}

export default function PropertiesEditor() {
  const appGlobalState = useAppGlobalState();
  const [fileName, setFileName] = useState("");
  const [pairs, setPairs] = useState([]); // Array of { key, value }
  const [jiraKey, setJiraKey] = useState("");
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [formData, setFormData] = useState(null);
  const [previewText, setPreviewText] = useState("");

  const location = useLocation();
  const navigate = useNavigate();

  // Fetch the default template and requirement details on mount.
  useEffect(() => {
    const fetchData = async () => {
      try {
        // 1. Get the default properties template.
        const templateResponse = await getPropertiesTemplate(appGlobalState);
        console.log("Template Response Data:", templateResponse);
        if (
          templateResponse &&
          templateResponse.templateObjList &&
          templateResponse.templateObjList.length > 0
        ) {
          const templateStr = templateResponse.templateObjList[0].json;
          const parsedPairs = parsePropertiesString(templateStr);
          setPairs(parsedPairs);
        } else {
          throw new Error("No template object found in the response");
        }

        // 2. Get requirement details using location.state.
        const reqResponse = await getRequirementDetails(location.state, appGlobalState);
        console.log("Requirement Response Data:", reqResponse.data);
        if (reqResponse && reqResponse.data && reqResponse.data.length > 0) {
          setFileName(reqResponse.data[0].tableName);
          setJiraKey(reqResponse.data[0].requirementId);
        } else {
          throw new Error("No requirement details found");
        }
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [location.state, appGlobalState]);

  // Update composite formData and live preview whenever jiraKey, fileName, or pairs change.
  useEffect(() => {
    const parameters = propertiesArrayToString(pairs);
    setFormData({
      requirementId: jiraKey,
      parameters,
      fileName,
    });
    setPreviewText(parameters);
  }, [jiraKey, fileName, pairs]);

  // Handler for updating a key-value pair.
  const handlePairChange = (index, newPair) => {
    const updatedPairs = [...pairs];
    updatedPairs[index] = newPair;
    setPairs(updatedPairs);
  };

  // Handler for removing a pair.
  const handleRemovePair = (index) => {
    const updatedPairs = pairs.filter((_, i) => i !== index);
    setPairs(updatedPairs);
  };

  // Handler for adding a new empty pair.
  const handleAddPair = () => {
    setPairs([...pairs, { key: "", value: "" }]);
  };

  // Handler for submitting (saving) the properties file.
  const handleSubmit = async () => {
    const requirement = {
      requirementId: jiraKey,
      parameters: propertiesArrayToString(pairs),
      fileName: fileName,
    };
    setFormData(requirement);
    try {
      const response = await createCMPPropFile(requirement, appGlobalState);
      console.log("Response from createCMPPropFile:", response.data);
      if (response.data.statusCode === 201) {
        alert("Properties File created successfully!");
        navigate("/createdcmpjil", { state: jiraKey });
      } else {
        alert(
          "Error: " +
            response.data.statusCode +
            " Properties File creation failed!"
        );
      }
    } catch (err) {
      console.error(err);
      alert("Error creating properties file: " + err.message);
    }
  };

  if (loading) return <div>Loading...</div>;
  if (error) return <div style={{ color: "red" }}>Error: {error.message}</div>;

  return (
    <div className="applicationContainer">
      <IngressNavigation />
      <h5>Properties File Configuration</h5>
      <div className="editor-container">
        <div className="editor-left">
          <h6>Edit Key-Value Pairs</h6>
          {pairs.map((pair, index) => (
            <KeyValuePair
              key={index}
              index={index}
              pair={pair}
              onChange={handlePairChange}
              onRemove={handleRemovePair}
            />
          ))}
          <button onClick={handleAddPair} className="add-button">
            Add New Pair
          </button>
          <div className="button-container">
            <DiaasButton title="Generate Properties File" handleChange={handleSubmit} />
          </div>
        </div>
        <div className="editor-right">
          <h6>Live Preview</h6>
          <textarea
            readOnly
            value={previewText}
            className="preview-textarea"
          />
        </div>
      </div>
    </div>
  );
}
```

---

### 2. **KeyValuePair.jsx**

```jsx
// KeyValuePair.jsx
import React from "react";
import PropTypes from "prop-types";
import "./PropertiesEditor.css";

export default function KeyValuePair({ index, pair, onChange, onRemove }) {
  const handleKeyChange = (e) => {
    onChange(index, { ...pair, key: e.target.value });
  };

  const handleValueChange = (e) => {
    onChange(index, { ...pair, value: e.target.value });
  };

  return (
    <div className="pair-row">
      <input
        type="text"
        placeholder="Key"
        value={pair.key}
        onChange={handleKeyChange}
        className="pair-input"
      />
      <span className="colon-separator">:</span>
      <input
        type="text"
        placeholder="Value"
        value={pair.value}
        onChange={handleValueChange}
        className="pair-input"
      />
      <button onClick={() => onRemove(index)} className="remove-button">
        Remove
      </button>
    </div>
  );
}

KeyValuePair.propTypes = {
  index: PropTypes.number.isRequired,
  pair: PropTypes.shape({
    key: PropTypes.string,
    value: PropTypes.string,
  }).isRequired,
  onChange: PropTypes.func.isRequired,
  onRemove: PropTypes.func.isRequired,
};
```

---

### 3. **propertiesActions.js**

```js
// propertiesActions.js
import axios from "axios";
import { MICROSERVICE_URL } from "../../../constant";
import { generateSearchHeader } from "../../../Authentication";

// Fetch the properties template.
export async function getPropertiesTemplate(appGlobalState) {
  const response = await axios.get(
    `${MICROSERVICE_URL}/api/v1/getPropertiesTemplate/COMPMPROP`,
    {
      headers: generateSearchHeader(appGlobalState),
    }
  );
  if (response.status !== 200 && response.status !== 201) {
    throw new Error(`Failed to fetch properties template: ${response.status}`);
  }
  return response.data;
}

// Fetch requirement details by requirement ID (passed via location.state).
export async function getRequirementDetails(requirementId, appGlobalState) {
  const response = await axios.get(
    `${MICROSERVICE_URL}/api/v1/searchRequirementForReqID/${requirementId}`,
    {
      headers: generateSearchHeader(appGlobalState),
    }
  );
  if (response.status !== 200 && response.status !== 201) {
    throw new Error(`Failed to fetch requirement details: ${response.status}`);
  }
  return response;
}

// Create (POST) the properties file.
export async function createCMPPropFile(requirement, appGlobalState) {
  const response = await axios.post(
    `${MICROSERVICE_URL}/api/v1/createCMPPropFile`,
    requirement,
    {
      headers: generateSearchHeader(appGlobalState),
    }
  );
  return response;
}
```

---

### 4. **propertiesEndpoint.js** (Optional)

```js
// propertiesEndpoint.js
export const propertiesEndpoint = {
  GET_TEMPLATE: "/api/v1/getPropertiesTemplate/COMPMPROP",
  GET_REQUIREMENT: "/api/v1/searchRequirementForReqID/",
  CREATE_FILE: "/api/v1/createCMPPropFile",
};
```

---

### 5. **PropertiesEditor.css**

```css
/* PropertiesEditor.css */

.applicationContainer {
  max-width: 900px;
  margin: 0 auto;
  padding: 20px;
  font-family: Arial, sans-serif;
}

.editor-container {
  display: flex;
  gap: 20px;
  margin-top: 20px;
}

/* Left side styling */
.editor-left {
  flex: 1;
  border: 1px solid #ccc;
  padding: 15px;
  border-radius: 5px;
}

/* Right side styling */
.editor-right {
  flex: 1;
  border: 1px solid #ccc;
  padding: 15px;
  border-radius: 5px;
}

.pair-row {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
}

.pair-input {
  padding: 6px;
  margin-right: 4px;
  flex: 1;
}

.colon-separator {
  margin-right: 4px;
}

.remove-button {
  background-color: #ff4d4f;
  color: white;
  border: none;
  padding: 6px 10px;
  cursor: pointer;
}

.remove-button:hover {
  background-color: #e04343;
}

.add-button {
  margin-top: 10px;
  padding: 8px 12px;
  cursor: pointer;
}

.button-container {
  display: flex;
  justify-content: center;
  margin-top: 20px;
}

.preview-textarea {
  width: 100%;
  height: 300px;
  padding: 10px;
  font-family: monospace;
  border: 1px solid #ccc;
  border-radius: 5px;
  resize: vertical;
}
```

---

### 6. **IngressNavigation.jsx (Stub)**

```jsx
// IngressNavigation.jsx
import React from "react";

export default function IngressNavigation() {
  return (
    <nav style={{ padding: "10px", backgroundColor: "#eee" }}>
      <span>Ingress Navigation</span>
    </nav>
  );
}
```

---

### 7. **DiaasButton.jsx (Stub)**

```jsx
// DiaasButton.jsx
import React from "react";
import PropTypes from "prop-types";

export default function DiaasButton({ title, handleChange }) {
  return (
    <button onClick={handleChange} style={{ padding: "10px 20px", fontSize: "16px" }}>
      {title}
    </button>
  );
}

DiaasButton.propTypes = {
  title: PropTypes.string.isRequired,
  handleChange: PropTypes.func.isRequired,
};
```

---

### How It All Fits Together

1. **PropertiesEditor.jsx**  
   - On mount, it fetches the default properties template and requirement details.  
   - It converts the raw template string into an array of key–value pairs (using `parsePropertiesString`), which are rendered using the **KeyValuePair** component.  
   - As the user edits or adds/removes pairs, the state updates and a live preview (a formatted text view) is displayed in the right pane.  
   - When the user clicks the **DiaasButton**, the updated properties file is submitted to the backend.

2. **KeyValuePair.jsx**  
   - Renders each row with inputs for the key and value and a button to remove that row.

3. **propertiesActions.js**  
   - Contains the API calls for fetching the template, requirement details, and for creating the properties file.

4. **IngressNavigation.jsx** and **DiaasButton.jsx**  
   - Provide basic navigation and button functionality as used in your project.

5. **PropertiesEditor.css**  
   - Provides styling for a two-column layout with an editable left panel and a live preview right panel.

---

This complete set of files should serve as a robust starting point for your Properties Editor. Feel free to modify or extend these files to better suit your project’s requirements. Let me know if you need any further adjustments or clarifications!
