import React, { useState, useEffect } from 'react';
import axios from 'axios';

// Import paths updated as per your project (using '../../../Authentication' for generateSearHeader)
// and MICROSERVICE_URL and useAppGlobalState from the constant module.
import { generateSearHeader } from '../../../Authentication';
import { useAppGlobalState } from '@wf/react-library';
import MICROSERVICE_URL from '../../../util/constant';

const NewBranchCreator = () => {
  // State for authentication and repository/branch dropdowns
  const [isAuthenticated, setIsAuthenticated] = useState(null);
  const [repositories, setRepositories] = useState([]);
  const [selectedRepo, setSelectedRepo] = useState(null);
  const [branches, setBranches] = useState([]);
  const [selectedBranch, setSelectedBranch] = useState('');
  const [loadingRepos, setLoadingRepos] = useState(false);
  const [loadingBranches, setLoadingBranches] = useState(false);

  // State for new branch and file push details
  const [newBranch, setNewBranch] = useState('');
  const [filePath, setFilePath] = useState('');
  const [commitMessage, setCommitMessage] = useState('');
  const [fileContent, setFileContent] = useState('');

  // UI feedback state
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [success, setSuccess] = useState(null);

  const appGlobalState = useAppGlobalState();

  // Fetch repositories on mount
  useEffect(() => {
    const fetchRepositories = async () => {
      setLoadingRepos(true);
      try {
        const response = await axios.get(`${MICROSERVICE_URL}/ghe/repositories`, {
          headers: generateSearHeader(appGlobalState),
          withCredentials: true,
        });
        setRepositories(response.data);
        setIsAuthenticated(true);
      } catch (err) {
        if (err.response && err.response.status === 401) {
          setIsAuthenticated(false);
        } else {
          setError(err.response ? err.response.data : err.message);
        }
      } finally {
        setLoadingRepos(false);
      }
    };
    fetchRepositories();
  }, [appGlobalState]);

  // When a repository is selected, fetch its branches
  useEffect(() => {
    const fetchBranches = async () => {
      setLoadingBranches(true);
      try {
        const response = await axios.get(`${MICROSERVICE_URL}/ghe/branches`, {
          params: {
            owner: selectedRepo.owner,
            repo: selectedRepo.name,
          },
          headers: generateSearHeader(appGlobalState),
          withCredentials: true,
        });
        setBranches(response.data);
      } catch (err) {
        setError(err.response ? err.response.data : err.message);
      } finally {
        setLoadingBranches(false);
      }
    };
    if (selectedRepo) {
      fetchBranches();
    }
  }, [selectedRepo, appGlobalState]);

  // Handlers for dropdowns
  const handleRepoChange = (e) => {
    const repoName = e.target.value;
    const repo = repositories.find((r) => r.name === repoName);
    setSelectedRepo(repo);
    setSelectedBranch('');
    setBranches([]);
  };

  const handleBranchChange = (e) => {
    setSelectedBranch(e.target.value);
  };

  // On form submit, create the new branch then push the file
  const handleSubmit = async () => {
    setError(null);
    setSuccess(null);
    if (!selectedRepo || !selectedBranch || !newBranch || !filePath || !commitMessage || !fileContent) {
      setError('Please fill in all fields.');
      return;
    }
    setLoading(true);
    try {
      // Step 1: Create the new branch
      const createBranchPayload = {
        operation: 'createBranch',
        owner: selectedRepo.owner,
        repo: selectedRepo.name,
        newBranch: newBranch,
        // Leave baseSha empty; backend will fetch using baseBranch
        baseSha: "",
        baseBranch: selectedBranch,
      };
      const branchResponse = await axios.post(`${MICROSERVICE_URL}/ghe/operation`, createBranchPayload, {
        headers: generateSearHeader(appGlobalState),
        withCredentials: true,
      });
      console.log("Branch creation response:", branchResponse.data);

      // Step 2: Push the file into the new branch
      // (Assuming the backend uses the 'newBranch' field to push the file to that branch)
      const filePayload = {
        operation: 'addFile',
        owner: selectedRepo.owner,
        repo: selectedRepo.name,
        filePath: filePath,
        commitMessage: commitMessage,
        content: btoa(fileContent), // Encode file content in Base64
        newBranch: newBranch,
      };
      const fileResponse = await axios.post(`${MICROSERVICE_URL}/ghe/operation`, filePayload, {
        headers: generateSearHeader(appGlobalState),
        withCredentials: true,
      });
      console.log("File push response:", fileResponse.data);

      setSuccess(`New branch '${newBranch}' created from '${selectedBranch}' and file pushed successfully.`);
    } catch (err) {
      setError(`Error: ${err.response ? err.response.data : err.message}`);
    } finally {
      setLoading(false);
    }
  };

  if (isAuthenticated === false) {
    return (
      <div>
        <h2>Authentication Required</h2>
        <p>Please log in with GitHub.</p>
      </div>
    );
  }

  if (isAuthenticated === null || loadingRepos) {
    return (
      <div>
        <h2>Loading repositories...</h2>
      </div>
    );
  }

  return (
    <div className="new-branch-creator">
      <h2>Create a New Branch and Push a File</h2>
      {error && <div className="error">{error}</div>}
      {success && <div className="success">{success}</div>}
      
      {/* Repository and Base Branch Selection */}
      <div className="form-group">
        <label>Repository:</label>
        <select value={selectedRepo ? selectedRepo.name : ''} onChange={handleRepoChange}>
          <option value="">-- Select Repository --</option>
          {repositories.map((repo) => (
            <option key={repo.name} value={repo.name}>
              {repo.name} ({repo.owner})
            </option>
          ))}
        </select>
      </div>

      {selectedRepo && (
        <div className="form-group">
          <label>Base Branch:</label>
          {loadingBranches ? (
            <p>Loading branches...</p>
          ) : (
            <select value={selectedBranch} onChange={handleBranchChange}>
              <option value="">-- Select Branch --</option>
              {branches.map((branch) => (
                <option key={branch} value={branch}>
                  {branch}
                </option>
              ))}
            </select>
          )}
        </div>
      )}

      {/* New Branch Name */}
      <div className="form-group">
        <label>New Branch Name:</label>
        <input
          type="text"
          value={newBranch}
          onChange={(e) => setNewBranch(e.target.value)}
          placeholder="Enter new branch name"
        />
      </div>

      <hr />

      {/* File Push Fields */}
      <h3>Push File Details</h3>
      <div className="form-group">
        <label>File Path:</label>
        <input
          type="text"
          value={filePath}
          onChange={(e) => setFilePath(e.target.value)}
          placeholder="e.g., src/data.json"
        />
      </div>
      <div className="form-group">
        <label>Commit Message:</label>
        <input
          type="text"
          value={commitMessage}
          onChange={(e) => setCommitMessage(e.target.value)}
          placeholder="Enter commit message"
        />
      </div>
      <div className="form-group">
        <label>File Content:</label>
        <textarea
          value={fileContent}
          onChange={(e) => setFileContent(e.target.value)}
          placeholder="Enter file content"
        />
      </div>

      <button onClick={handleSubmit} disabled={loading}>
        {loading ? 'Processing...' : 'Create Branch & Push File'}
      </button>
    </div>
  );
};

export default NewBranchCreator;
