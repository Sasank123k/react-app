package com.wellsfargo.utcap.controller;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.wellsfargo.utcap.dto.GitOperationRequest;
import com.wellsfargo.utcap.model.GithubClientProperties;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.*;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;

import java.io.IOException;
import java.util.Arrays;
import java.util.Collections;
import java.util.UUID;

@RestController
@RequestMapping("/ghe")
public class GithubController {

    private static final Logger log = LoggerFactory.getLogger(GithubController.class);
    private static final String GHE_API_BASE = "https://github.wellsfargo.com/api/v3/";

    private final GithubClientProperties githubClientProperties;

    public GithubController(GithubClientProperties githubClientProperties) {
        this.githubClientProperties = githubClientProperties;
    }

    // --- OAuth Endpoints ---

    /**
     * Initiates the OAuth flow by redirecting the user to GitHub Enterprise's OAuth page.
     * Generates and stores a random state for CSRF protection.
     */
    @GetMapping("/auth")
    public void redirectToGithub(HttpServletResponse response, HttpSession session) throws IOException {
        String state = UUID.randomUUID().toString();
        session.setAttribute("GITHUB_OAUTH_STATE", state);
        log.info("In /auth: Session ID: {} | State set: '{}'", session.getId(), state);

        String clientId = githubClientProperties.getId();
        String redirectUri = "http://localhost:8080/ghe/callback";
        String authorizationUrl = "https://github.wellsfargo.com/login/oauth/authorize"
                + "?client_id=" + clientId
                + "&redirect_uri=" + redirectUri
                + "&scope=repo"
                + "&state=" + state;
        response.sendRedirect(authorizationUrl);
    }

    /**
     * Handles the OAuth callback from GitHub Enterprise.
     * It verifies the state, exchanges the code for an access token, stores the token in session,
     * sets a custom header and cookie, and then redirects the user to the frontend.
     */
    @GetMapping("/callback")
    public void handleGithubCallback(
            @RequestParam("code") String code,
            @RequestParam("state") String state,
            HttpSession session,
            HttpServletResponse response) throws IOException {

        log.info("In /callback: Session ID: {}", session.getId());
        String sessionState = (String) session.getAttribute("GITHUB_OAUTH_STATE");
        log.info("In /callback: Stored state: '{}' | Received state: '{}'", sessionState, state);

        if (sessionState == null || !sessionState.equals(state)) {
            response.sendError(HttpStatus.UNAUTHORIZED.value(), "Invalid state parameter");
            return;
        }

        // Exchange the code for an access token
        String accessToken = getAccessTokenFromGhe(code);
        log.info("Access Token: {}", accessToken);

        // Store the access token in session
        session.setAttribute("GHE_ACCESS_TOKEN", accessToken);
        log.info("before redirect");
        // Set custom headers if needed (for tracking, etc.)
        response.addHeader("X-REQUEST-ID", UUID.randomUUID().toString());
        // Explicitly set the session cookie so that the browser holds it
        Cookie sessionCookie = new Cookie("JSESSIONID", session.getId());
        sessionCookie.setPath("/");
        sessionCookie.setHttpOnly(true);
        response.addCookie(sessionCookie);

        // Redirect the user to the frontend page after successful authentication
        response.sendRedirect("http://localhost:3000/githubintegrationpage");
        log.info("after redirect");
    }

    /**
     * Exchanges the OAuth code for an access token by calling GitHub Enterprise's token endpoint.
     */
    private String getAccessTokenFromGhe(String code) {
        String tokenUrl = "https://github.wellsfargo.com/login/oauth/access_token";
        RestTemplate restTemplate = new RestTemplate();

        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("client_id", githubClientProperties.getId());
        params.add("client_secret", githubClientProperties.getSecret());
        params.add("code", code);

        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);
        headers.add("X-REQUEST-ID", UUID.randomUUID().toString());
        headers.add("X-CORRELATION-ID", UUID.randomUUID().toString());
        headers.add("X-CLIENT-ID", "UTCAP");
        HttpEntity<MultiValueMap<String, String>> requestEntity = new HttpEntity<>(params, headers);

        ResponseEntity<String> response = restTemplate.exchange(tokenUrl, HttpMethod.POST, requestEntity, String.class);
        String responseBody = response.getBody();
        log.info("Token endpoint response: {}", responseBody);

        return Arrays.stream(responseBody.split("&"))
                .filter(s -> s.startsWith("access_token"))
                .map(s -> s.split("=")[1])
                .findFirst()
                .orElseThrow(() -> new RuntimeException("No access token found"));
    }

    // --- API Endpoints for Repositories and Branches ---

    /**
     * Returns repositories where the authenticated user has push access.
     */
    @GetMapping("/repositories")
    public ResponseEntity<?> getRepositories(HttpSession session) {
        String accessToken = (String) session.getAttribute("GHE_ACCESS_TOKEN");
        if (accessToken == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Not authenticated");
        }

        RestTemplate restTemplate = new RestTemplate();
        String url = GHE_API_BASE + "/user/repos";
        HttpHeaders headers = buildAuthHeaders(accessToken);
        HttpEntity<?> entity = new HttpEntity<>(headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
        String responseBody = response.getBody();
        log.info("Repositories API response status: {}", response.getStatusCode());

        ObjectMapper objectMapper = new ObjectMapper();
        try {
            JsonNode rootArray = objectMapper.readTree(responseBody);
            com.fasterxml.jackson.databind.node.ArrayNode filteredRepos = objectMapper.createArrayNode();
            if (rootArray.isArray()) {
                for (JsonNode repoNode : rootArray) {
                    JsonNode permissions = repoNode.get("permissions");
                    if (permissions != null && permissions.get("push").asBoolean()) {
                        ObjectNode simpleRepo = objectMapper.createObjectNode();
                        simpleRepo.put("name", repoNode.get("name").asText());
                        simpleRepo.put("owner", repoNode.get("owner").get("login").asText());
                        filteredRepos.add(simpleRepo);
                    }
                }
            }
            return ResponseEntity.ok(filteredRepos);
        } catch (Exception e) {
            log.error("Error parsing repositories", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error processing repositories");
        }
    }

    /**
     * Returns branch names and their latest commit SHA for a given repository.
     */
    @GetMapping("/branches")
    public ResponseEntity<?> getBranches(@RequestParam("owner") String owner,
                                         @RequestParam("repo") String repo,
                                         HttpSession session) {
        String accessToken = (String) session.getAttribute("GHE_ACCESS_TOKEN");
        if (accessToken == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Not authenticated");
        }

        RestTemplate restTemplate = new RestTemplate();
        String url = GHE_API_BASE + "/repos/" + owner + "/" + repo + "/branches";
        HttpHeaders headers = buildAuthHeaders(accessToken);
        HttpEntity<?> entity = new HttpEntity<>(headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);
        String responseBody = response.getBody();
        log.info("Branches API response: {}", responseBody);

        ObjectMapper objectMapper = new ObjectMapper();
        try {
            JsonNode root = objectMapper.readTree(responseBody);
            // Create an array of branch objects with "name" and "commitSha"
            com.fasterxml.jackson.databind.node.ArrayNode branchArray = objectMapper.createArrayNode();
            if (root.isArray()) {
                for (JsonNode branch : root) {
                    ObjectNode branchObject = objectMapper.createObjectNode();
                    branchObject.put("name", branch.get("name").asText());
                    if (branch.has("commit") && branch.get("commit").has("sha")) {
                        branchObject.put("commitSha", branch.get("commit").get("sha").asText());
                    } else {
                        branchObject.put("commitSha", "");
                    }
                    branchArray.add(branchObject);
                }
            }
            return ResponseEntity.ok(branchArray);
        } catch (Exception e) {
            log.error("Error parsing branches", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error processing branches");
        }
    }

    // --- API Endpoint for Git Operations ---

    /**
     * Performs various Git operations (create branch, update file, add file, merge branch)
     * based on the operation specified in the GitOperationRequest.
     */
    @PostMapping("/operation")
    public ResponseEntity<?> performOperation(@RequestBody GitOperationRequest request, HttpSession session) {
        String accessToken = (String) session.getAttribute("GHE_ACCESS_TOKEN");
        if (accessToken == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body("Not authenticated");
        }

        try {
            String result;
            switch (request.getOperation()) {
                case "createBranch":
                    result = createBranch(accessToken, request);
                    break;
                case "updateFile":
                    result = updateFile(accessToken, request);
                    break;
                case "addFile":
                    result = addFile(accessToken, request);
                    break;
                case "mergeBranch":
                    result = mergeBranch(accessToken, request);
                    break;
                default:
                    return ResponseEntity.badRequest().body("Invalid operation: " + request.getOperation());
            }
            return ResponseEntity.ok(result);
        } catch (Exception ex) {
            log.error("Operation failed", ex);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Operation failed: " + ex.getMessage());
        }
    }

    // --- Helper Methods for Git Operations ---

    private String createBranch(String accessToken, GitOperationRequest request) {
        String url = GHE_API_BASE + "/repos/" + request.getOwner() + "/" + request.getRepo() + "/git/refs";
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders headers = buildAuthHeaders(accessToken);
        headers.setContentType(MediaType.APPLICATION_JSON);
        String payload = String.format("{\"ref\": \"refs/heads/%s\", \"sha\": \"%s\"}",
                request.getNewBranch(), request.getBaseSha());

        HttpEntity<String> entity = new HttpEntity<>(payload, headers);
        ResponseEntity<String> response = restTemplate.postForEntity(url, entity, String.class);
        log.info("Create branch response: {}", response.getBody());
        return response.getBody();
    }

    private String updateFile(String accessToken, GitOperationRequest request) {
        String url = GHE_API_BASE + "/repos/" + request.getOwner() + "/" + request.getRepo()
                + "/contents/" + request.getFilePath();
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders headers = buildAuthHeaders(accessToken);
        headers.setContentType(MediaType.APPLICATION_JSON);
        String payload = String.format("{\"message\": \"%s\", \"content\": \"%s\", \"sha\": \"%s\"}",
                request.getCommitMessage(), request.getContent(), request.getFileSha());

        HttpEntity<String> entity = new HttpEntity<>(payload, headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.PUT, entity, String.class);
        log.info("Update file response: {}", response.getBody());
        return response.getBody();
    }

    private String addFile(String accessToken, GitOperationRequest request) {
        String url = GHE_API_BASE + "/repos/" + request.getOwner() + "/" + request.getRepo()
                + "/contents/" + request.getFilePath();
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders headers = buildAuthHeaders(accessToken);
        headers.setContentType(MediaType.APPLICATION_JSON);
        String payload = String.format("{\"message\": \"%s\", \"content\": \"%s\"}",
                request.getCommitMessage(), request.getContent());

        HttpEntity<String> entity = new HttpEntity<>(payload, headers);
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.PUT, entity, String.class);
        log.info("Add file response: {}", response.getBody());
        return response.getBody();
    }

    private String mergeBranch(String accessToken, GitOperationRequest request) {
        String url = GHE_API_BASE + "/repos/" + request.getOwner() + "/" + request.getRepo() + "/merges";
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders headers = buildAuthHeaders(accessToken);
        headers.setContentType(MediaType.APPLICATION_JSON);
        String payload = String.format("{\"base\": \"%s\", \"head\": \"%s\", \"commit_message\": \"%s\"}",
                request.getBaseBranch(), request.getHeadBranch(), request.getCommitMessage());

        HttpEntity<String> entity = new HttpEntity<>(payload, headers);
        ResponseEntity<String> response = restTemplate.postForEntity(url, entity, String.class);
        log.info("Merge branch response: {}", response.getBody());
        return response.getBody();
    }

    /**
     * Utility method to build HTTP headers for GitHub API requests.
     * Sets the Authorization header with the access token,
     * and adds custom headers for API versioning and request tracing.
     */
    private HttpHeaders buildAuthHeaders(String accessToken) {
        HttpHeaders headers = new HttpHeaders();
        headers.set("Authorization", "token " + accessToken);
        headers.setAccept(Collections.singletonList(MediaType.parseMediaType("application/vnd.github.v3+json")));
        headers.add("X-REQUEST-ID", UUID.randomUUID().toString());
        headers.add("X-CORRELATION-ID", UUID.randomUUID().toString());
        headers.add("X-CLIENT-ID", "UTCAP");
        return headers;
    }
}
