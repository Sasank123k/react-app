Below is the complete updated code for the affected files. In these revisions we have:

1. Moved the “Add New Pair” functionality so that when the user clicks the button, two inline input boxes appear below the existing key–value pairs (instead of using a prompt).  
2. Moved the dropdown for adding child jobs to the header area of each job (BOX, CMD, FW) and, for non–main box jobs, added a “Remove Job” button in that header.  
3. Added a “Remove” button next to each key–value pair row.  
4. Increased the input sizes via CSS.  
5. Made the left (structured) editor scrollable.

A helper function (`fillDefaults`) is added in **jilUtils.js** to create a new job with default values from the metadata (a simplified version).  
All files use the .jsx extension and share a single CSS file for styling.

---

### 1. **JILEditorContainer.jsx**

```jsx
import React, { useState, useEffect } from "react";
import JILEditor from "./JILEditor";
import JILNavigation from "./JILNavigation";
import { JILEditorProvider } from "./JILEditorContext";
import { MICROSERVICE_URL } from "../util/constant";
import generateSearchHeader from "../util/Authentication";
import { useGlobalState } from "../react-library";
import "./JILEditor.css";

const JILEditorContainer = ({ requirementId }) => {
  // For now, assume EDL flow with one JIL file by default.
  const [jilFiles, setJilFiles] = useState([]);
  const [loading, setLoading] = useState(true);
  const [currentFileIndex, setCurrentFileIndex] = useState(0);
  const globalState = useGlobalState();

  useEffect(() => {
    fetch(`${MICROSERVICE_URL}/api/jilData/${requirementId}`, {
      method: "GET",
      headers: generateSearchHeader(globalState)
    })
      .then((res) => res.json())
      .then((data) => {
        if (data.jilFiles && data.jilFiles.length > 0) {
          setJilFiles(data.jilFiles);
        } else {
          // If no file is returned, initialize with an empty default structure.
          setJilFiles([{ mainBox: {} }]);
        }
        setLoading(false);
      })
      .catch((err) => {
        console.error("Error fetching JIL data:", err);
        setLoading(false);
      });
  }, [requirementId, globalState]);

  const addNewFile = () => {
    setJilFiles([...jilFiles, { mainBox: {} }]);
    setCurrentFileIndex(jilFiles.length);
  };

  const updateCurrentFile = (updatedFile) => {
    const newFiles = jilFiles.map((file, index) =>
      index === currentFileIndex ? updatedFile : file
    );
    setJilFiles(newFiles);
  };

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <JILEditorProvider
      value={{ jilFiles, setJilFiles, currentFileIndex, updateCurrentFile }}
    >
      <div className="jil-editor-container">
        <JILNavigation
          currentFileIndex={currentFileIndex}
          setCurrentFileIndex={setCurrentFileIndex}
          totalFiles={jilFiles.length}
          addNewFile={addNewFile}
        />
        <JILEditor requirementId={requirementId} />
      </div>
    </JILEditorProvider>
  );
};

export default JILEditorContainer;
```

---

### 2. **JILNavigation.jsx**

```jsx
import React from "react";

const JILNavigation = ({ currentFileIndex, setCurrentFileIndex, totalFiles, addNewFile }) => {
  return (
    <div className="jil-navigation">
      <button
        onClick={() =>
          setCurrentFileIndex((prev) => Math.max(prev - 1, 0))
        }
        disabled={currentFileIndex === 0}
      >
        &lt; Prev
      </button>
      <span>
        File {currentFileIndex + 1} of {totalFiles}
      </span>
      <button
        onClick={() =>
          setCurrentFileIndex((prev) =>
            Math.min(prev + 1, totalFiles - 1)
          )
        }
        disabled={currentFileIndex === totalFiles - 1}
      >
        Next &gt;
      </button>
      <button onClick={addNewFile}>Add File</button>
    </div>
  );
};

export default JILNavigation;
```

---

### 3. **JILEditor.jsx**

```jsx
import React, { useState, useEffect, useContext } from "react";
import { JILEditorContext } from "./JILEditorContext";
import JILFieldRenderer from "./JILFieldRenderer";
import { MICROSERVICE_URL } from "../util/constant";
import generateSearchHeader from "../util/Authentication";
import { useGlobalState } from "../react-library";
import { convertToJILText } from "./jilUtils";
import "./JILEditor.css";

const JILEditor = ({ requirementId }) => {
  const { jilFiles, currentFileIndex, updateCurrentFile } = useContext(JILEditorContext);
  const [metadata, setMetadata] = useState(null);
  const [rawPreview, setRawPreview] = useState("");
  const globalState = useGlobalState();
  const currentFile = jilFiles[currentFileIndex];

  // Fetch JIL metadata.
  useEffect(() => {
    fetch(`${MICROSERVICE_URL}/api/jilMetadata`, {
      method: "GET",
      headers: generateSearchHeader(globalState)
    })
      .then((res) => res.json())
      .then((data) => {
        setMetadata(data.metaData);
      })
      .catch((err) => {
        console.error("Error fetching metadata:", err);
      });
  }, [globalState]);

  // Update live preview on current file changes.
  useEffect(() => {
    // For now, using JSON conversion. Later replace with convertToJILText(currentFile).
    const previewText = convertToJILText(currentFile);
    setRawPreview(previewText);
  }, [currentFile]);

  const handleSave = () => {
    fetch(`${MICROSERVICE_URL}/api/jilData/${requirementId}`, {
      method: "PUT",
      headers: {
        ...generateSearchHeader(globalState),
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ jilFiles })
    })
      .then((res) => {
        if (!res.ok) {
          throw new Error("Save failed");
        }
        return res.json();
      })
      .then(() => {
        alert("JIL file saved successfully!");
      })
      .catch((err) => {
        console.error("Error saving JIL file:", err);
      });
  };

  if (!metadata) {
    return <div>Loading metadata...</div>;
  }

  return (
    <div className="jil-editor">
      <div className="jil-editor-header">
        <h3>JIL Editor</h3>
        <button onClick={handleSave}>Save</button>
      </div>
      <div className="jil-editor-body">
        <div className="jil-editor-left">
          <h4>Structured Editor</h4>
          {/* Render the mainBox of the current file */}
          <JILFieldRenderer
            schema={metadata.properties.mainBox}
            data={currentFile.mainBox || {}}
            path={["mainBox"]}
            onFieldChange={(updatedData) => {
              updateCurrentFile({ ...currentFile, mainBox: updatedData });
            }}
          />
        </div>
        <div className="jil-editor-right">
          <h4>Live Preview</h4>
          <textarea readOnly value={rawPreview} />
        </div>
      </div>
    </div>
  );
};

export default JILEditor;
```

---

### 4. **JILFieldRenderer.jsx**

```jsx
import React from "react";
import JILBoxEditor from "./JILBoxEditor";
import JILCmdEditor from "./JILCmdEditor";
import JILFwEditor from "./JILFwEditor";

const JILFieldRenderer = ({ schema, data, path, onFieldChange, onRemoveJob }) => {
  // If schema has oneOf, choose one based on data.job_type or default to first option.
  if (schema.oneOf) {
    let selectedSchema = schema.oneOf[0];
    if (data.job_type) {
      const found = schema.oneOf.find((s) => {
        if (s.$ref && data.job_type) {
          return s.$ref.includes(data.job_type);
        }
        return false;
      });
      if (found) {
        selectedSchema = found;
      }
    }
    // Render according to job type.
    if (selectedSchema.$ref && selectedSchema.$ref.includes("SubBOX")) {
      return (
        <JILBoxEditor
          schema={selectedSchema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    } else if (selectedSchema.$ref && selectedSchema.$ref.includes("CMD")) {
      return (
        <JILCmdEditor
          schema={selectedSchema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    } else if (selectedSchema.$ref && selectedSchema.$ref.includes("FW")) {
      return (
        <JILFwEditor
          schema={selectedSchema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    } else {
      return (
        <JILBoxEditor
          schema={selectedSchema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    }
  }

  // Fallback based on data.job_type.
  switch (data.job_type) {
    case "BOX":
      return (
        <JILBoxEditor
          schema={schema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    case "CMD":
      return (
        <JILCmdEditor
          schema={schema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    case "FW":
      return (
        <JILFwEditor
          schema={schema}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    default:
      return <div>Unknown job type</div>;
  }
};

export default JILFieldRenderer;
```

---

### 5. **JILBoxEditor.jsx**

```jsx
import React, { useState } from "react";
import JILFieldRenderer from "./JILFieldRenderer";
import { fillDefaults } from "./jilUtils";

const JILBoxEditor = ({ schema, data, path, onFieldChange, onRemoveJob }) => {
  // Local state for inline new key/value pair addition.
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  // Update a field in the current BOX job.
  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  // Remove a key-value pair.
  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  // Render existing key-value pairs (excluding 'properties').
  const renderKeyValuePairs = () => {
    return Object.keys(data)
      .filter((k) => k !== "properties")
      .map((key, idx) => (
        <div key={idx} className="jil-keyvalue-row">
          <label>{key}: </label>
          <input
            className="jil-input"
            type="text"
            value={data[key]}
            onChange={(e) => handleChange(key, e.target.value)}
          />
          <button
            className="jil-remove-btn"
            onClick={() => removeKeyValuePair(key)}
          >
            Remove
          </button>
        </div>
      ));
  };

  // Inline add new pair section.
  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  // Update a child job in the properties array.
  const handleChildChange = (index, childData) => {
    const newProperties = data.properties ? [...data.properties] : [];
    newProperties[index] = childData;
    handleChange("properties", newProperties);
  };

  // Add a new child job using defaults from metadata.
  const addChildJob = (jobType) => {
    let newJob = {};
    // Use the fillDefaults helper to create a new job with default values.
    if (jobType === "BOX") {
      newJob = fillDefaults(schema.items.find(item => item.$ref && item.$ref.includes("SubBOX")) || {});
    } else if (jobType === "CMD") {
      newJob = fillDefaults(schema.items.find(item => item.$ref && item.$ref.includes("CMD")) || {});
    } else if (jobType === "FW") {
      newJob = fillDefaults(schema.items.find(item => item.$ref && item.$ref.includes("FW")) || {});
    }
    // Ensure newJob has the job_type set.
    newJob.job_type = jobType;
    if (jobType === "BOX") newJob.properties = [];
    const newProperties = data.properties ? [...data.properties, newJob] : [newJob];
    handleChange("properties", newProperties);
  };

  // Render child jobs.
  const renderChildJobs = () => {
    const children = data.properties || [];
    return children.map((child, index) => (
      <div key={index} className="jil-child-job">
        <JILFieldRenderer
          schema={schema.items ? schema.items : {}}
          data={child}
          path={[...path, "properties", index]}
          onFieldChange={(childData) => handleChildChange(index, childData)}
          onRemoveJob={() => {
            // Remove child at index.
            const newProperties = data.properties.filter((_, idx) => idx !== index);
            handleChange("properties", newProperties);
          }}
        />
      </div>
    ));
  };

  return (
    <div className="jil-box-editor">
      <div className="jil-job-header">
        <span>{path[0] === "mainBox" ? "Main Box Job" : "Sub Box"}</span>
        <div className="jil-header-actions">
          {/* Dropdown for adding child job */}
          <select
            className="jil-job-dropdown"
            onChange={(e) => {
              if (e.target.value) {
                addChildJob(e.target.value);
                e.target.value = "";
              }
            }}
          >
            <option value="">Add Child Job...</option>
            <option value="BOX">Sub Box</option>
            <option value="CMD">CMD</option>
            <option value="FW">FW</option>
          </select>
          {/* Show remove job button if not main box */}
          {!(path.length === 1 && path[0] === "mainBox") && (
            <button
              className="jil-remove-job-btn"
              onClick={() => onRemoveJob && onRemoveJob()}
            >
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-box-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
      <div className="jil-child-section">
        <h5>Child Jobs</h5>
        {renderChildJobs()}
      </div>
    </div>
  );
};

export default JILBoxEditor;
```

---

### 6. **JILCmdEditor.jsx**

```jsx
import React, { useState } from "react";
import { fillDefaults } from "./jilUtils";

const JILCmdEditor = ({ schema, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  const renderKeyValuePairs = () => {
    return Object.keys(data).map((key, idx) => (
      <div key={idx} className="jil-keyvalue-row">
        <label>{key}: </label>
        <input
          className="jil-input"
          type="text"
          value={data[key]}
          onChange={(e) => handleChange(key, e.target.value)}
        />
        <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
          Remove
        </button>
      </div>
    ));
  };

  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  return (
    <div className="jil-cmd-editor">
      <div className="jil-job-header">
        <span>CMD Job</span>
        <div className="jil-header-actions">
          {/* For CMD jobs, no child job dropdown is needed */}
          {!(path && path[0] === "mainBox") && (
            <button className="jil-remove-job-btn" onClick={() => onRemoveJob && onRemoveJob()}>
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-cmd-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
    </div>
  );
};

export default JILCmdEditor;
```

---

### 7. **JILFwEditor.jsx**

```jsx
import React, { useState } from "react";
import { fillDefaults } from "./jilUtils";

const JILFwEditor = ({ schema, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  const renderKeyValuePairs = () => {
    return Object.keys(data).map((key, idx) => (
      <div key={idx} className="jil-keyvalue-row">
        <label>{key}: </label>
        <input
          className="jil-input"
          type="text"
          value={data[key]}
          onChange={(e) => handleChange(key, e.target.value)}
        />
        <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
          Remove
        </button>
      </div>
    ));
  };

  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  return (
    <div className="jil-fw-editor">
      <div className="jil-job-header">
        <span>File Watcher Job (FW)</span>
        <div className="jil-header-actions">
          {!(path && path[0] === "mainBox") && (
            <button className="jil-remove-job-btn" onClick={() => onRemoveJob && onRemoveJob()}>
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-fw-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
    </div>
  );
};

export default JILFwEditor;
```

---

### 8. **(Optional) JILKeyValueEditor.jsx**

*(Not strictly required since the inline code is now in each editor; you may remove this file if not used.)*

```jsx
import React from "react";

const JILKeyValueEditor = ({ label, value, onChange, onRemove }) => {
  return (
    <div className="jil-keyvalue-row">
      <label>{label}: </label>
      <input type="text" value={value} onChange={(e) => onChange(e.target.value)} className="jil-input"/>
      <button className="jil-remove-btn" onClick={onRemove}>Remove</button>
    </div>
  );
};

export default JILKeyValueEditor;
```

---

### 9. **jilUtils.js**

```js
// A simple utility to convert the internal JSON structure to JIL text.
// For now, it returns a formatted JSON string.
// Also includes a helper to fill defaults based on the provided schema.
export const convertToJILText = (jilJson) => {
  return JSON.stringify(jilJson, null, 2);
};

// A basic fillDefaults function that returns an object with default values.
// This is a simplified version – in a real implementation you might recursively fill in defaults.
export const fillDefaults = (schema) => {
  const defaults = {};
  if (schema && schema.properties) {
    Object.keys(schema.properties).forEach((key) => {
      const prop = schema.properties[key];
      defaults[key] = prop.default !== undefined ? prop.default : "";
    });
  }
  return defaults;
};
```

---

### 10. **JILEditorContext.jsx**

```jsx
import React, { createContext } from "react";

export const JILEditorContext = createContext();

export const JILEditorProvider = JILEditorContext.Provider;
```

---

### 11. **JILEditor.css**

```css
/* Container & Global Styles */
.jil-editor-container {
  margin: 20px;
  font-family: Arial, sans-serif;
}

.jil-navigation {
  margin-bottom: 10px;
}

.jil-navigation button {
  margin-right: 5px;
}

/* Editor Layout */
.jil-editor {
  display: flex;
  flex-direction: column;
}

.jil-editor-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.jil-editor-body {
  display: flex;
  margin-top: 10px;
}

.jil-editor-left,
.jil-editor-right {
  width: 50%;
  padding: 10px;
}

/* Make the left panel scrollable */
.jil-editor-left {
  max-height: 600px;
  overflow-y: auto;
}

/* Live preview styling */
.jil-editor-right textarea {
  width: 100%;
  height: 400px;
}

/* Job Editor Styles */
.jil-box-editor,
.jil-cmd-editor,
.jil-fw-editor {
  border: 1px solid #ccc;
  padding: 10px;
  margin-bottom: 10px;
}

.jil-job-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #f2f2f2;
  padding: 5px;
  margin-bottom: 10px;
}

.jil-header-actions {
  display: flex;
  align-items: center;
}

.jil-job-dropdown {
  margin-right: 10px;
}

.jil-remove-job-btn {
  background-color: #e57373;
  color: white;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
}

.jil-remove-job-btn:hover {
  background-color: #ef5350;
}

/* Key-Value Row Styles */
.jil-keyvalue-row {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
}

.jil-keyvalue-row label {
  width: 150px;
  font-weight: bold;
}

.jil-input {
  width: 300px; /* increased size */
  padding: 4px;
  margin-right: 10px;
}

.jil-remove-btn {
  background-color: #e57373;
  color: white;
  border: none;
  padding: 2px 6px;
  cursor: pointer;
}

.jil-remove-btn:hover {
  background-color: #ef5350;
}

/* New Pair Inline Section */
.jil-new-pair-row {
  display: flex;
  align-items: center;
  margin-top: 10px;
}

.jil-add-btn {
  background-color: #81c784;
  color: white;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
  margin-left: 10px;
}

.jil-add-btn:hover {
  background-color: #66bb6a;
}

.jil-add-pair-btn {
  background-color: #64b5f6;
  color: white;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
  margin-top: 10px;
}

.jil-add-pair-btn:hover {
  background-color: #42a5f5;
}

/* Child Jobs Section */
.jil-child-job {
  margin-left: 20px;
  margin-top: 10px;
}

.jil-child-section h5 {
  margin-bottom: 5px;
}
```

---

### Final Notes

- **State Management:**  
  Each job editor (BOX, CMD, FW) now manages local state to show inline new pair inputs. When the user fills in and clicks “Add,” the key–value pair is added to the job’s data and the inline section is hidden.

- **Job Removal:**  
  In the header of each job (except the main box), a “Remove Job” button is rendered. The actual removal should be handled by the parent component via the `onRemoveJob` callback (passed from the parent through `JILFieldRenderer`).

- **Child Job Addition:**  
  The dropdown for adding a child job is now at the top in the job header. When a new job is added, the helper function `fillDefaults` from **jilUtils.js** populates the job with default key–value pairs from the metadata (a simplified approach).

- **Scrolling & Input Sizes:**  
  The left panel is now scrollable and the input boxes have increased size according to the CSS.

These complete updated files should implement the changes as described. Feel free to adjust the styling or logic as needed for your project!
