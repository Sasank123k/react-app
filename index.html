Below is an updated version of the two frontend files. In this update, we add a new API call (via a function in the actions file) to fetch the requirement details so we can extract the table name. Then, in the PropertiesEditor component, after fetching the properties file/template, we call this new function to get the table name and then set the file name as <tablename>_gcp.properties.


---

1. Updated propertiesActions.js

This file now includes a new function getRequirementDetails that calls your endpoint (which returns a list where response.data[0].tablename is the table name). The function returns the data (so the caller can extract the table name).

// propertiesActions.js
import axios from "axios";
import { MICROSERVICE_URL } from "../../../constant";
import { generateSearchHeader } from "../../../Authentication";

/**
 * GET the updated file or default template for a requirement.
 * Endpoint: /api/v1/getPropertiesFileOrTemplate/{requirementId}
 */
export async function getPropertiesFileOrTemplate(requirementId, appGlobalState) {
  const response = await axios.get(
    `${MICROSERVICE_URL}/api/v1/getPropertiesFileOrTemplate/${requirementId}`,
    {
      headers: generateSearchHeader(appGlobalState),
    }
  );
  if (response.status !== 200 && response.status !== 201) {
    throw new Error(`Failed to fetch properties: ${response.status}`);
  }
  return response.data;
}

/**
 * GET the requirement details to derive the file name.
 * Expected response: an array with at least one object having a field "tablename".
 */
export async function getRequirementDetails(requirementId, appGlobalState) {
  const response = await axios.get(
    `${MICROSERVICE_URL}/api/v1/searchRequirementForReqID/${requirementId}`,
    {
      headers: generateSearchHeader(appGlobalState),
    }
  );
  if (response.status !== 200 && response.status !== 201) {
    throw new Error(`Failed to fetch requirement details: ${response.status}`);
  }
  return response.data;
}

/**
 * POST to create (or update) the properties file.
 * Endpoint: /api/v1/createCMPPropFile
 */
export async function createCMPPropFile(requirement, appGlobalState) {
  const response = await fetch(`${MICROSERVICE_URL}/api/v1/createCMPPropFile`, {
    method: "POST",
    headers: generateSearchHeader(appGlobalState),
    body: JSON.stringify(requirement),
  });
  return response.json();
}


---

2. Updated PropertiesEditor.jsx

In this file, we now call the new getRequirementDetails API to get the table name. We then set the file name as <tablename>_gcp.properties. (We assume that the location.state now holds the requirement ID that we need.)

We also keep all our previous UI and parsing logic.

// PropertiesEditor.jsx
import React, { useEffect, useState, useMemo } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import { useAppGlobalState } from "@wf/react-library";
import { MICROSERVICE_URL } from "../../../constant";
import { generateSearchHeader } from "../../../Authentication";
import IngressNavigation from "../../Workflow/IngressNavigation";
import DiaasButton from "../../../components/DiaasButton";
import "./PropertiesEditor.css";
import { 
  getPropertiesFileOrTemplate, 
  getRequirementDetails, 
  createCMPPropFile 
} from "./propertiesActions";
import KeyValuePair from "./KeyValuePair";

/**
 * When parsing the properties string, we use "=" as the separator.
 * Also, if a value ends with ",\" (as added in preview), we remove it for editing.
 */
function parsePropertiesString(str) {
  if (!str) return [];
  const lines = str.split("\n");
  return lines.map((line) => {
    const equalIndex = line.indexOf("=");
    let key = "";
    let value = "";
    if (equalIndex !== -1) {
      key = line.slice(0, equalIndex).trim();
      value = line.slice(equalIndex + 1).trim();
    } else {
      key = line.trim();
      value = "";
    }
    // Strip trailing ",\" if present
    if (value.endsWith(",\\")) {
      value = value.slice(0, -2).trim();
    }
    return { key, value };
  });
}

/**
 * Converts an array of key-value pairs back to a properties string.
 * In the preview, each value gets appended with ",\".
 */
function propertiesArrayToString(pairs) {
  return pairs
    .map(({ key, value }) => {
      // Append delimiter only in the preview representation if a value exists
      const finalValue = value ? `${value},\\` : value;
      return `${key}=${finalValue}`;
    })
    .join("\n");
}

export default function PropertiesEditor() {
  const appGlobalState = useAppGlobalState();
  const [pairs, setPairs] = useState([]); // Array of { key, value }
  const [requirementId, setRequirementId] = useState("");
  const [fileName, setFileName] = useState("");
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [previewText, setPreviewText] = useState("");

  const location = useLocation();
  const navigate = useNavigate();

  // Assume location.state holds the requirementId.
  const stableRequirementId = useMemo(() => location.state, [location.state]);

  useEffect(() => {
    const fetchData = async () => {
      try {
        // 1. Fetch the properties file (updated file or default template)
        const result = await getPropertiesFileOrTemplate(stableRequirementId, appGlobalState);
        if (!result.json) {
          throw new Error("No 'json' field found in the properties response");
        }
        // Set requirementId from the response if available, otherwise use the one passed in
        setRequirementId(result.requirementId || stableRequirementId);
        const parsedPairs = parsePropertiesString(result.json);
        setPairs(parsedPairs);

        // 2. Fetch the requirement details to derive the file name.
        const reqDetails = await getRequirementDetails(stableRequirementId, appGlobalState);
        if (reqDetails && reqDetails.length > 0 && reqDetails[0].tablename) {
          const tableName = reqDetails[0].tablename;
          setFileName(`${tableName}_gcp.properties`);
        } else {
          throw new Error("No requirement details (tablename) found");
        }
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [stableRequirementId, appGlobalState]);

  // Update live preview when pairs change
  useEffect(() => {
    const preview = propertiesArrayToString(pairs);
    setPreviewText(preview);
  }, [pairs]);

  // Handlers for key-value pair changes
  const handlePairChange = (index, newPair) => {
    const updatedPairs = [...pairs];
    updatedPairs[index] = newPair;
    setPairs(updatedPairs);
  };

  const handleRemovePair = (index) => {
    setPairs(pairs.filter((_, i) => i !== index));
  };

  const handleAddPair = () => {
    setPairs([...pairs, { key: "", value: "" }]);
  };

  // Handler for submitting the properties file
  const handleSubmit = async () => {
    const finalString = propertiesArrayToString(pairs);
    const requirement = {
      requirementId,
      // Assuming the backend expects the properties string under the "json" field.
      json: finalString,
      fileName,
    };
    try {
      const response = await createCMPPropFile(requirement, appGlobalState);
      if (response && response.statusCode === 201) {
        alert("Properties File created successfully!");
        navigate("/createdcmpjil", { state: requirementId });
      } else {
        const code = response ? response.statusCode : "undefined";
        alert("Errorcode:" + code + " - Properties File creation failed!");
      }
    } catch (err) {
      console.error("Error creating properties file:", err);
      alert("Error: " + err.message);
    }
  };

  if (loading) return <div>Loading...</div>;
  if (error) return <div style={{ color: "red" }}>Error: {error.message}</div>;

  return (
    <div className="applicationContainer">
      <IngressNavigation />
      <h5>Properties File Configuration</h5>
      <div className="editor-container">
        {/* Left panel: Editable key-value pairs */}
        <div className="editor-left">
          <h6>Edit Key-Value Pairs</h6>
          <div className="pairs-scroll">
            {pairs.map((pair, index) => (
              <KeyValuePair
                key={index}
                index={index}
                pair={pair}
                onChange={handlePairChange}
                onRemove={handleRemovePair}
              />
            ))}
          </div>
          <button onClick={handleAddPair} className="add-button">
            Add New Pair
          </button>
        </div>
        {/* Right panel: Live preview */}
        <div className="editor-right">
          <h6>Live Preview</h6>
          <div className="preview-scroll">
            <textarea
              readOnly
              value={previewText}
              className="preview-textarea"
            />
          </div>
        </div>
      </div>
      {/* Generate button placed below the editor container */}
      <div className="generate-button-container">
        <DiaasButton title="Generate Properties File" handleChange={handleSubmit} />
      </div>
    </div>
  );
}


---

Explanation of Changes

Requirement Details:
The new function getRequirementDetails in the actions file is called in the PropertiesEditor component. We extract the table name from response.data[0].tablename and set the file name as <tablename>_gcp.properties.

Requirement ID:
The updated endpoint that returns the properties file now includes the requirement ID. If the returned object does not include it, we default to the requirement ID passed via location.state.

UI:
The overall UI layout remains the two-column structure with scrollable panels and the generate button below the editor container.


Let me know if you need further adjustments or additional clarifications!

