aBelow is the updated code for the files that require changes. In these updates we now:

• Fetch the metadata (and store the full metadata object along with its definitions) in the container and pass it via context.
• Use the metadata definitions when creating a default JIL file (so that the new file always comes pre‑populated with a main box having one CMD job).
• Ensure that state updates trigger the live preview (by using a dependency that reflects deep changes).
• Preserve all of your previously implemented functions and only add the missing parts.

Below are the updated files:


---

Updated JILEditorContainer.jsx

import React, { useState, useEffect } from "react";
import JILEditor from "./JILEditor";
import JILNavigation from "./JILNavigation";
import { JILEditorProvider } from "./JILEditorContext";
import { MICROSERVICE_URL } from "../../../util/Constant";
import { generateSearHeader } from "../../../Authenitcation";
import { useAppGlobalState } from "@wf/react-library";
import { createDefaultJILFile } from "./jilUtils";
import "./JILEditor.css";

const JILEditorContainer = ({ requirementId }) => {
  const [jilFiles, setJilFiles] = useState([]);
  const [metadata, setMetadata] = useState(null); // store full metadata (including definitions)
  const [loading, setLoading] = useState(true);
  const [currentFileIndex, setCurrentFileIndex] = useState(0);
  const { token } = useAppGlobalState();

  // Fetch metadata
  useEffect(() => {
    fetch(`${MICROSERVICE_URL}/api/jilMetadata`, {
      method: "GET",
      headers: generateSearHeader(token)
    })
      .then((res) => res.json())
      .then((data) => {
        // Metadata is returned as an array – take the first element’s metaData.
        setMetadata(data[0].metaData);
      })
      .catch((err) => {
        console.error("Error fetching metadata:", err);
      });
  }, [token]);

  // Fetch JIL files data
  useEffect(() => {
    fetch(`${MICROSERVICE_URL}/api/jilData/${requirementId}`, {
      method: "GET",
      headers: generateSearHeader(token)
    })
      .then((res) => res.json())
      .then((data) => {
        if (data.jilFiles && data.jilFiles.length > 0) {
          setJilFiles(data.jilFiles);
        } else {
          // If no file exists, create a default one if metadata is available.
          if (metadata && metadata.definitions) {
            setJilFiles([createDefaultJILFile(metadata.definitions)]);
          } else {
            // Fallback if metadata not ready.
            setJilFiles([{ mainBox: {} }]);
          }
        }
        setLoading(false);
      })
      .catch((err) => {
        console.error("Error fetching JIL data:", err);
        setLoading(false);
      });
  }, [requirementId, token, metadata]);

  // Handler to add a new file.
  // It now uses metadata.definitions to create a default file.
  const addNewFile = () => {
    if (!metadata || !metadata.definitions) {
      alert("Metadata is not available yet.");
      return;
    }
    const newFile = createDefaultJILFile(metadata.definitions);
    setJilFiles([...jilFiles, newFile]);
    setCurrentFileIndex(jilFiles.length);
  };

  // Delete the current file.
  const deleteFile = () => {
    if (jilFiles.length > 1) {
      const newFiles = jilFiles.filter((_, index) => index !== currentFileIndex);
      setJilFiles(newFiles);
      setCurrentFileIndex(Math.max(currentFileIndex - 1, 0));
    } else {
      alert("At least one JIL file must exist.");
    }
  };

  if (loading) {
    return <div>Loading...</div>;
  }

  // Pass metadata along with other state via context.
  const contextValue = {
    jilFiles,
    setJilFiles,
    currentFileIndex,
    setCurrentFileIndex,
    metadata
  };

  return (
    <JILEditorProvider value={contextValue}>
      <div className="jil-editor-container">
        <JILNavigation
          currentFileIndex={currentFileIndex}
          setCurrentFileIndex={setCurrentFileIndex}
          totalFiles={jilFiles.length}
          addNewFile={addNewFile}
          deleteFile={deleteFile}
        />
        <JILEditor requirementId={requirementId} />
      </div>
    </JILEditorProvider>
  );
};

export default JILEditorContainer;


---

Updated JILEditor.jsx

import React, { useState, useEffect, useContext } from "react";
import { JILEditorContext } from "./JILEditorContext";
import JILFieldRenderer from "./JILFieldRenderer";
import { MICROSERVICE_URL } from "../../../util/Constant";
import { generateSearHeader } from "../../../Authenitcation";
import { useAppGlobalState } from "@wf/react-library";
import { convertToJILText } from "./jilUtils";
import "./JILEditor.css";

const JILEditor = ({ requirementId }) => {
  const { jilFiles, currentFileIndex, setJilFiles, metadata } = useContext(JILEditorContext);
  const [rawPreview, setRawPreview] = useState("");
  const { token } = useAppGlobalState();
  const currentFile = jilFiles[currentFileIndex];

  // (Metadata is already fetched in the container)

  // Update live preview when current file changes.
  useEffect(() => {
    // Use JSON.stringify to force deep re-evaluation
    const previewText = convertToJILText(currentFile);
    setRawPreview(previewText);
  }, [JSON.stringify(currentFile)]); // deep dependency

  const handleSave = () => {
    fetch(`${MICROSERVICE_URL}/api/jilData/${requirementId}`, {
      method: "PUT",
      headers: {
        ...generateSearHeader(token),
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ jilFiles })
    })
      .then((res) => {
        if (!res.ok) {
          throw new Error("Save failed");
        }
        return res.json();
      })
      .then(() => {
        alert("JIL file saved successfully!");
      })
      .catch((err) => {
        console.error("Error saving JIL file:", err);
      });
  };

  if (!metadata) {
    return <div>Loading metadata...</div>;
  }

  return (
    <div className="jil-editor">
      <div className="jil-editor-header">
        <h3>JIL Editor</h3>
        <button onClick={handleSave}>Save</button>
      </div>
      <div className="jil-editor-body">
        <div className="jil-editor-left scroll-container">
          <h4>Structured Editor</h4>
          <div className="scroll-content">
            <JILFieldRenderer
              schema={metadata.definitions.MainBOX}
              definitions={metadata.definitions}
              data={currentFile.mainBox || {}}
              path={["mainBox"]}
              onFieldChange={(updatedData) => {
                const newFiles = [...jilFiles];
                newFiles[currentFileIndex].mainBox = updatedData;
                setJilFiles(newFiles);
              }}
            />
          </div>
        </div>
        <div className="jil-editor-right scroll-container">
          <h4>Live Preview</h4>
          <textarea readOnly value={rawPreview} />
        </div>
      </div>
    </div>
  );
};

export default JILEditor;


---

Updated JILBoxEditor.jsx

import React, { useState } from "react";
import JILFieldRenderer from "./JILFieldRenderer";
import { fillDefaults } from "./jilUtils";

const JILBoxEditor = ({ schema, definitions, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  const renderKeyValuePairs = () => {
    return Object.keys(data)
      .filter((k) => k !== "properties")
      .map((key, idx) => (
        <div key={idx} className="jil-keyvalue-row">
          <label>{key}: </label>
          <input
            className="jil-input"
            type="text"
            value={data[key]}
            onChange={(e) => handleChange(key, e.target.value)}
          />
          <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
            Remove
          </button>
        </div>
      ));
  };

  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  const handleChildChange = (index, childData) => {
    const newProperties = data.properties ? [...data.properties] : [];
    newProperties[index] = childData;
    handleChange("properties", newProperties);
  };

  // Use definitions from context to create a default new child job.
  const addChildJob = (jobType) => {
    let newJob = {};
    if (jobType === "BOX") {
      newJob = fillDefaults(definitions.SubBOX);
    } else if (jobType === "CMD") {
      newJob = fillDefaults(definitions.CMD);
    } else if (jobType === "FW") {
      newJob = fillDefaults(definitions.FW);
    }
    newJob.job_type = jobType;
    if (jobType === "BOX") newJob.properties = [];
    const newProperties = data.properties ? [...data.properties, newJob] : [newJob];
    handleChange("properties", newProperties);
  };

  const renderChildJobs = () => {
    const children = data.properties || [];
    return children.map((child, index) => (
      <div key={index} className="jil-child-job">
        <JILFieldRenderer
          schema={child.job_type === "BOX" ? definitions.SubBOX : {}}
          definitions={definitions}
          data={child}
          path={[...path, "properties", index]}
          onFieldChange={(childData) => handleChildChange(index, childData)}
          onRemoveJob={() => {
            const newProperties = data.properties.filter((_, idx) => idx !== index);
            handleChange("properties", newProperties);
          }}
        />
      </div>
    ));
  };

  return (
    <div className="jil-box-editor">
      <div className="jil-job-header">
        <span>{path[0] === "mainBox" && path.length === 1 ? "Main Box Job" : "Sub Box"}</span>
        <div className="jil-header-actions">
          <select
            className="jil-job-dropdown"
            onChange={(e) => {
              if (e.target.value) {
                addChildJob(e.target.value);
                e.target.value = "";
              }
            }}
          >
            <option value="">Add Child Job...</option>
            <option value="BOX">Sub Box</option>
            <option value="CMD">CMD</option>
            <option value="FW">FW</option>
          </select>
          {path.length > 1 && (
            <button className="jil-remove-job-btn" onClick={() => onRemoveJob && onRemoveJob()}>
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-box-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
      <div className="jil-child-section">
        <h5>Child Jobs</h5>
        {renderChildJobs()}
      </div>
    </div>
  );
};

export default JILBoxEditor;


---

Updated JILUtils.js

// Converts the internal JSON structure into formatted JIL text.
export const convertToJILText = (jilJson) => {
  // Recursive function to format a job.
  const formatJob = (job) => {
    const jobName = job.insert_job || "Unknown Job";
    let output = `/*----------------- ${jobName} ------------------*/\n\n`;
    Object.keys(job).forEach((key) => {
      if (key !== "properties") {
        output += `${key}: ${job[key]}\n`;
      }
    });
    output += "\n";
    if (job.properties && Array.isArray(job.properties)) {
      job.properties.forEach((child) => {
        output += formatJob(child) + "\n";
      });
    }
    return output;
  };
  return formatJob(jilJson.mainBox);
};

// Helper to fill defaults based on the given schema.
export const fillDefaults = (schema) => {
  const defaults = {};
  if (schema && schema.properties) {
    Object.keys(schema.properties).forEach((key) => {
      const prop = schema.properties[key];
      defaults[key] = prop.default !== undefined ? prop.default : "";
    });
  }
  return defaults;
};

// Create a default JIL file using the provided definitions.
// It creates a main box populated from definitions.MainBOX and
// one default CMD job from definitions.CMD.
export const createDefaultJILFile = (definitions) => {
  return {
    mainBox: {
      ...fillDefaults(definitions.MainBOX),
      properties: [
        {
          ...fillDefaults(definitions.CMD),
          job_type: "CMD"
        }
      ]
    }
  };
};


---

Final Remarks

• The JILEditorContainer.jsx now fetches metadata and stores it in state; it also passes the full metadata (including definitions) via context so that file‑creation (and child‑job creation) functions can use the correct default schema.
• The JILEditor.jsx now uses a deep dependency (via JSON.stringify of the current file) to ensure that changes in the left-side editor update the right-side preview.
• The JILBoxEditor.jsx now uses the metadata definitions (passed as a prop) to correctly create sub‑jobs with default values, and the remove button now appears for any job that is not the top-level main box.
• The JILUtils.js file’s functions have been updated to generate default file structures and convert internal JSON into the JIL text format (mimicking your sample).

These changes should address your current issues and provide the proper mechanisms for future enhancements. Let me know if you have any further questions or require additional adjustments.

