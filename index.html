Below is an example implementation for your SQL editor page using React. In this example, we use:

- **react-ace** and **ace-builds** to render the code editor.  
- **sql-formatter** to format the SQL content.
- A dropdown to select between the two SQL files (“Create SQL” and “Delete SQL”).
- A **Format** button that formats the active editor content.
- A **Save** button that formats both SQL file contents and calls the update endpoint.

You can adjust the endpoint URLs and requirement id as needed. The code is split into a JSX file (for the component) and a CSS file (for styling).

---

### 1. SQL Editor Page Component (SqlEditorPage.jsx)

```jsx
import React, { useEffect, useState } from 'react';
import AceEditor from 'react-ace';
import sqlFormatter from 'sql-formatter';
import 'ace-builds/src-noconflict/mode-sql';
import 'ace-builds/src-noconflict/theme-github';
import './SqlEditorPage.css'; // Ensure this file is in the same folder or adjust the path accordingly.

function SqlEditorPage() {
  // For demonstration we hardcode the requirement id; in production, this might come from props, route params, etc.
  const requirementId = "BZLS-4501";

  // State to hold the two SQL files
  const [sqlFiles, setSqlFiles] = useState({
    createSqlContent: '',
    deleteSqlContent: ''
  });

  // State for the currently active file and its content
  const [activeFile, setActiveFile] = useState('create'); // possible values: 'create' or 'delete'
  const [editorContent, setEditorContent] = useState('');

  const [loading, setLoading] = useState(true);

  // Fetch SQL file from backend on component mount
  useEffect(() => {
    fetch(`/api/sql/${requirementId}`)
      .then(response => response.json())
      .then(data => {
        // Auto-format the SQL files initially using sqlFormatter
        const formattedCreate = sqlFormatter.format(data.createSqlContent);
        const formattedDelete = sqlFormatter.format(data.deleteSqlContent);

        // Save formatted files to state
        const files = {
          createSqlContent: formattedCreate,
          deleteSqlContent: formattedDelete
        };
        setSqlFiles(files);
        // Set the active editor content (default to Create SQL)
        setEditorContent(formattedCreate);
        setLoading(false);
      })
      .catch(error => {
        console.error("Error fetching SQL files:", error);
        setLoading(false);
      });
  }, [requirementId]);

  // Handle change in the dropdown selection
  const handleFileChange = (event) => {
    const selected = event.target.value;
    setActiveFile(selected);
    if (selected === 'create') {
      setEditorContent(sqlFiles.createSqlContent);
    } else {
      setEditorContent(sqlFiles.deleteSqlContent);
    }
  };

  // Handle editor content change
  const handleEditorChange = (newValue) => {
    setEditorContent(newValue);
    // Update the correct SQL file in state
    setSqlFiles(prev => {
      if (activeFile === 'create') {
        return { ...prev, createSqlContent: newValue };
      } else {
        return { ...prev, deleteSqlContent: newValue };
      }
    });
  };

  // Format the active SQL file using sql-formatter
  const handleFormat = () => {
    const formatted = sqlFormatter.format(editorContent);
    setEditorContent(formatted);
    setSqlFiles(prev => {
      if (activeFile === 'create') {
        return { ...prev, createSqlContent: formatted };
      } else {
        return { ...prev, deleteSqlContent: formatted };
      }
    });
  };

  // Save button click handler – format both files and call the update endpoint
  const handleSave = () => {
    // Format both files before saving
    const formattedCreate = sqlFormatter.format(sqlFiles.createSqlContent);
    const formattedDelete = sqlFormatter.format(sqlFiles.deleteSqlContent);

    // Update state with the formatted values
    const updatedFiles = {
      createSqlContent: formattedCreate,
      deleteSqlContent: formattedDelete
    };
    setSqlFiles(updatedFiles);
    if (activeFile === 'create') {
      setEditorContent(formattedCreate);
    } else {
      setEditorContent(formattedDelete);
    }

    // Call the backend update endpoint
    fetch(`/api/sql/${requirementId}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(updatedFiles)
    })
      .then(response => {
        if (!response.ok) {
          throw new Error('Failed to update SQL files');
        }
        return response.json();
      })
      .then(data => {
        alert('SQL files updated successfully.');
      })
      .catch(error => {
        console.error("Error saving SQL files:", error);
        alert('Error updating SQL files. Please try again.');
      });
  };

  if (loading) {
    return <div>Loading SQL editor...</div>;
  }

  return (
    <div className="sql-editor-page">
      <div className="toolbar">
        <select value={activeFile} onChange={handleFileChange}>
          <option value="create">Create SQL</option>
          <option value="delete">Delete SQL</option>
        </select>
        <button onClick={handleFormat}>Format</button>
        <button onClick={handleSave}>Save</button>
      </div>
      <AceEditor
        mode="sql"
        theme="github"
        name="sql-editor"
        value={editorContent}
        onChange={handleEditorChange}
        width="100%"
        height="500px"
        setOptions={{
          enableBasicAutocompletion: true,
          enableLiveAutocompletion: true,
        }}
      />
    </div>
  );
}

export default SqlEditorPage;
```

---

### 2. CSS File (SqlEditorPage.css)

Below is a basic CSS setup for the page. You can further adjust styles to fit your project’s design guidelines.

```css
.sql-editor-page {
  margin: 20px;
  padding: 20px;
  font-family: Arial, sans-serif;
}

.toolbar {
  display: flex;
  align-items: center;
  margin-bottom: 10px;
}

.toolbar select {
  margin-right: 10px;
  padding: 5px;
  font-size: 14px;
}

.toolbar button {
  margin-right: 10px;
  padding: 5px 10px;
  font-size: 14px;
  cursor: pointer;
  border: 1px solid #ccc;
  background-color: #f5f5f5;
}

.toolbar button:hover {
  background-color: #e0e0e0;
}
```

---

### How It Works

1. **Initialization:**  
   When the component mounts, it fetches the two SQL files from the backend using the requirement id. Once fetched, each file is auto-formatted and then stored in state.

2. **Dropdown Navigation:**  
   The dropdown lets the user select which SQL file to view/edit (Create SQL or Delete SQL). When a selection changes, the editor content is updated accordingly.

3. **Formatting:**  
   Clicking the **Format** button runs the current editor content through `sqlFormatter.format` and updates both the editor content and the state.

4. **Saving:**  
   On clicking **Save**, both SQL file contents are re-formatted and sent to the backend via a POST request to the update endpoint.

This setup provides a clean and simple SQL editor using react-ace, with essential features like auto-format on load, formatting on demand, and saving formatted SQL back to the backend. Feel free to extend or refine this base as your project requirements evolve.
