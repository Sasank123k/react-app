Below is the complete updated code for all the affected files. These changes address your future requirements by:

1. Default JIL File Structure:
 • When a user clicks “Add File” (from the navigation), the new file will now be initialized using a helper function (in jilUtils.js) that creates a default file with a main box (populated from metadata.definitions.MainBOX) and one CMD job (populated from metadata.definitions.CMD).
 • This ensures that instead of “unknown job type” or simply “mainbox”, the default file shows proper key–value pairs from the metadata.


2. Raw Preview in JIL File Format:
 • The conversion function in jilUtils.js (convertToJILText) has been updated to output text in a format that mimics your sample—for each job a comment header is created (with dashes and the job name) followed by the key–value pairs.


3. Delete Button for JIL Files:
 • In the navigation area (JILNavigation.jsx), a “Delete File” button has been added at the top (below the “Add File” button). When pressed, it removes the current file from the JIL files array.


4. UI Adjustments:
 • The left structured editor now has an inner scrollable container below its heading so that its scroll bar appears in the same place as on the right preview.
 • The left and right panels have been given the same fixed height.
 • The key–value pair inputs have been widened; key labels now have black color (instead of red) and the key label width is reduced relative to the value input.



Below are the updated full code files:


---

1. JILEditorContainer.jsx

import React, { useState, useEffect } from "react";
import JILEditor from "./JILEditor";
import JILNavigation from "./JILNavigation";
import { JILEditorProvider } from "./JILEditorContext";
import { MICROSERVICE_URL } from "../../../util/Constant";
import { generateSearHeader } from "../../../Authenitcation";
import { useAppGlobalState } from "@wf/react-library";
import { createDefaultJILFile } from "./jilUtils";
import "./JILEditor.css";

const JILEditorContainer = ({ requirementId }) => {
  const [jilFiles, setJilFiles] = useState([]);
  const [loading, setLoading] = useState(true);
  const [currentFileIndex, setCurrentFileIndex] = useState(0);
  const { token } = useAppGlobalState();

  // Fetch existing JIL files from backend
  useEffect(() => {
    fetch(`${MICROSERVICE_URL}/api/jilData/${requirementId}`, {
      method: "GET",
      headers: generateSearHeader(token)
    })
      .then((res) => res.json())
      .then((data) => {
        if (data.jilFiles && data.jilFiles.length > 0) {
          setJilFiles(data.jilFiles);
        } else {
          // If no file, create a default one.
          // Here we use a hard-coded default; ideally, this would use metadata,
          // but for the initial load we use our default helper.
          setJilFiles([{
            mainBox: {
              insert_job: "<job name>",
              job_type: "BOX",
              owner: "<owner name>",
              permission: "me,mx,ge,gx,we,wx",
              date_condition: 0,
              description: "<description>",
              alarm_if_fail: 0,
              alarm_if_terminated: 0,
              timezone: "US/Pacific",
              group: "<group name>",
              application: "<app name>",
              properties: [{
                insert_job: "<job name>",
                job_type: "CMD",
                box_name: "<parent sub-box job name>",
                command: "<command>",
                machine: "<machine name>",
                owner: "<owner name>",
                permission: "me,mx,ge,gx,we,wx",
                date_condition: 0,
                condition: "<condition>",
                description: "<description>",
                std_out_file: "<filename>",
                std_err_file: "<filename>",
                alarm_if_fail: 1,
                profile: "<profile name>",
                job_load: 30,
                priority: 290,
                alarm_if_terminated: 1,
                timezone: "US/Pacific",
                group: "<group name>",
                application: "<app name>"
              }]
            }
          }]);
        }
        setLoading(false);
      })
      .catch((err) => {
        console.error("Error fetching JIL data:", err);
        setLoading(false);
      });
  }, [requirementId, token]);

  // Use metadata (once loaded in JILEditor) for new file defaults.
  // For now, assume we use a helper that creates a default file structure.
  const addNewFile = (defaultDefinitions) => {
    // When adding a new file, create a default structure:
    const newFile = createDefaultJILFile(defaultDefinitions);
    setJilFiles([...jilFiles, newFile]);
    setCurrentFileIndex(jilFiles.length);
  };

  const deleteFile = () => {
    if (jilFiles.length > 1) {
      const newFiles = jilFiles.filter((_, index) => index !== currentFileIndex);
      setJilFiles(newFiles);
      setCurrentFileIndex(Math.max(currentFileIndex - 1, 0));
    } else {
      alert("At least one JIL file must exist.");
    }
  };

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <JILEditorProvider value={{ jilFiles, setJilFiles, currentFileIndex, setCurrentFileIndex }}>
      <div className="jil-editor-container">
        <JILNavigation
          currentFileIndex={currentFileIndex}
          setCurrentFileIndex={setCurrentFileIndex}
          totalFiles={jilFiles.length}
          addNewFile={addNewFile}
          deleteFile={deleteFile}
        />
        <JILEditor requirementId={requirementId} />
      </div>
    </JILEditorProvider>
  );
};

export default JILEditorContainer;


---

2. JILNavigation.jsx

import React from "react";

const JILNavigation = ({ currentFileIndex, setCurrentFileIndex, totalFiles, addNewFile, deleteFile }) => {
  return (
    <div className="jil-navigation">
      <button
        onClick={() => setCurrentFileIndex((prev) => Math.max(prev - 1, 0))}
        disabled={currentFileIndex === 0}
      >
        &lt; Prev
      </button>
      <span>
        File {currentFileIndex + 1} of {totalFiles}
      </span>
      <button
        onClick={() =>
          setCurrentFileIndex((prev) =>
            Math.min(prev + 1, totalFiles - 1)
          )
        }
        disabled={currentFileIndex === totalFiles - 1}
      >
        Next &gt;
      </button>
      <button onClick={() => addNewFile(null)}>Add File</button>
      <button onClick={deleteFile} className="jil-delete-file-btn">
        Delete File
      </button>
    </div>
  );
};

export default JILNavigation;


---

3. JILEditor.jsx

import React, { useState, useEffect, useContext } from "react";
import { JILEditorContext } from "./JILEditorContext";
import JILFieldRenderer from "./JILFieldRenderer";
import { MICROSERVICE_URL } from "../../../util/Constant";
import { generateSearHeader } from "../../../Authenitcation";
import { useAppGlobalState } from "@wf/react-library";
import { convertToJILText } from "./jilUtils";
import "./JILEditor.css";

const JILEditor = ({ requirementId }) => {
  const { jilFiles, currentFileIndex, setCurrentFileIndex, setJilFiles } = useContext(JILEditorContext);
  const [metadata, setMetadata] = useState(null);
  const [rawPreview, setRawPreview] = useState("");
  const { token } = useAppGlobalState();
  const currentFile = jilFiles[currentFileIndex];

  // Fetch metadata from backend
  useEffect(() => {
    fetch(`${MICROSERVICE_URL}/api/jilMetadata`, {
      method: "GET",
      headers: generateSearHeader(token)
    })
      .then((res) => res.json())
      .then((data) => {
        // Assume metadata is an array; pick the first element.
        setMetadata(data[0].metaData);
      })
      .catch((err) => {
        console.error("Error fetching metadata:", err);
      });
  }, [token]);

  // Update live preview using our conversion function.
  useEffect(() => {
    const previewText = convertToJILText(currentFile);
    setRawPreview(previewText);
  }, [currentFile]);

  const handleSave = () => {
    fetch(`${MICROSERVICE_URL}/api/jilData/${requirementId}`, {
      method: "PUT",
      headers: {
        ...generateSearHeader(token),
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ jilFiles })
    })
      .then((res) => {
        if (!res.ok) {
          throw new Error("Save failed");
        }
        return res.json();
      })
      .then(() => {
        alert("JIL file saved successfully!");
      })
      .catch((err) => {
        console.error("Error saving JIL file:", err);
      });
  };

  if (!metadata) {
    return <div>Loading metadata...</div>;
  }

  return (
    <div className="jil-editor">
      <div className="jil-editor-header">
        <h3>JIL Editor</h3>
        <button onClick={handleSave}>Save</button>
      </div>
      <div className="jil-editor-body">
        <div className="jil-editor-left scroll-container">
          <h4>Structured Editor</h4>
          <div className="scroll-content">
            <JILFieldRenderer
              schema={metadata.definitions.MainBOX}
              definitions={metadata.definitions}
              data={currentFile.mainBox || {}}
              path={["mainBox"]}
              onFieldChange={(updatedData) => {
                const newFiles = [...jilFiles];
                newFiles[currentFileIndex].mainBox = updatedData;
                setJilFiles(newFiles);
              }}
            />
          </div>
        </div>
        <div className="jil-editor-right scroll-container">
          <h4>Live Preview</h4>
          <textarea readOnly value={rawPreview} />
        </div>
      </div>
    </div>
  );
};

export default JILEditor;


---

4. JILFieldRenderer.jsx

import React from "react";
import JILBoxEditor from "./JILBoxEditor";
import JILCmdEditor from "./JILCmdEditor";
import JILFwEditor from "./JILFwEditor";

const JILFieldRenderer = ({ schema, definitions, data, path, onFieldChange, onRemoveJob }) => {
  // If schema has oneOf, use it to select the correct schema for child jobs.
  if (schema.oneOf) {
    let selectedSchema = schema.oneOf[0];
    if (data.job_type) {
      const found = schema.oneOf.find((s) => {
        if (s.$ref && data.job_type) {
          return s.$ref.includes(data.job_type);
        }
        return false;
      });
      if (found) {
        selectedSchema = found;
      }
    }
    if (selectedSchema.$ref && selectedSchema.$ref.includes("SubBOX")) {
      return (
        <JILBoxEditor
          schema={selectedSchema}
          definitions={definitions}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    } else if (selectedSchema.$ref && selectedSchema.$ref.includes("CMD")) {
      return (
        <JILCmdEditor
          schema={selectedSchema}
          definitions={definitions}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    } else if (selectedSchema.$ref && selectedSchema.$ref.includes("FW")) {
      return (
        <JILFwEditor
          schema={selectedSchema}
          definitions={definitions}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    } else {
      return (
        <JILBoxEditor
          schema={selectedSchema}
          definitions={definitions}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    }
  }

  // Fallback if no oneOf.
  switch (data.job_type) {
    case "BOX":
      return (
        <JILBoxEditor
          schema={schema}
          definitions={definitions}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    case "CMD":
      return (
        <JILCmdEditor
          schema={schema}
          definitions={definitions}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    case "FW":
      return (
        <JILFwEditor
          schema={schema}
          definitions={definitions}
          data={data}
          path={path}
          onFieldChange={onFieldChange}
          onRemoveJob={onRemoveJob}
        />
      );
    default:
      return <div>Unknown job type</div>;
  }
};

export default JILFieldRenderer;


---

5. JILBoxEditor.jsx

import React, { useState } from "react";
import JILFieldRenderer from "./JILFieldRenderer";
import { fillDefaults } from "./jilUtils";

const JILBoxEditor = ({ schema, definitions, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  const renderKeyValuePairs = () => {
    return Object.keys(data)
      .filter((k) => k !== "properties")
      .map((key, idx) => (
        <div key={idx} className="jil-keyvalue-row">
          <label>{key}: </label>
          <input
            className="jil-input"
            type="text"
            value={data[key]}
            onChange={(e) => handleChange(key, e.target.value)}
          />
          <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
            Remove
          </button>
        </div>
      ));
  };

  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  const handleChildChange = (index, childData) => {
    const newProperties = data.properties ? [...data.properties] : [];
    newProperties[index] = childData;
    handleChange("properties", newProperties);
  };

  // Use the definitions passed from metadata to create the default new job.
  const addChildJob = (jobType) => {
    let newJob = {};
    if (jobType === "BOX") {
      newJob = fillDefaults(definitions.SubBOX);
    } else if (jobType === "CMD") {
      newJob = fillDefaults(definitions.CMD);
    } else if (jobType === "FW") {
      newJob = fillDefaults(definitions.FW);
    }
    newJob.job_type = jobType;
    if (jobType === "BOX") newJob.properties = [];
    const newProperties = data.properties ? [...data.properties, newJob] : [newJob];
    handleChange("properties", newProperties);
  };

  const renderChildJobs = () => {
    const children = data.properties || [];
    return children.map((child, index) => (
      <div key={index} className="jil-child-job">
        <JILFieldRenderer
          schema={child.job_type === "BOX" ? definitions.SubBOX : {}}
          definitions={definitions}
          data={child}
          path={[...path, "properties", index]}
          onFieldChange={(childData) => handleChildChange(index, childData)}
          onRemoveJob={() => {
            const newProperties = data.properties.filter((_, idx) => idx !== index);
            handleChange("properties", newProperties);
          }}
        />
      </div>
    ));
  };

  return (
    <div className="jil-box-editor">
      <div className="jil-job-header">
        <span>{path[0] === "mainBox" && path.length === 1 ? "Main Box Job" : "Sub Box"}</span>
        <div className="jil-header-actions">
          <select
            className="jil-job-dropdown"
            onChange={(e) => {
              if (e.target.value) {
                addChildJob(e.target.value);
                e.target.value = "";
              }
            }}
          >
            <option value="">Add Child Job...</option>
            <option value="BOX">Sub Box</option>
            <option value="CMD">CMD</option>
            <option value="FW">FW</option>
          </select>
          {path.length > 1 && (
            <button className="jil-remove-job-btn" onClick={() => onRemoveJob && onRemoveJob()}>
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-box-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
      <div className="jil-child-section">
        <h5>Child Jobs</h5>
        {renderChildJobs()}
      </div>
    </div>
  );
};

export default JILBoxEditor;


---

5. JILCmdEditor.jsx

import React, { useState } from "react";

const JILCmdEditor = ({ schema, definitions, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  const renderKeyValuePairs = () => {
    return Object.keys(data).map((key, idx) => (
      <div key={idx} className="jil-keyvalue-row">
        <label>{key}: </label>
        <input
          className="jil-input"
          type="text"
          value={data[key]}
          onChange={(e) => handleChange(key, e.target.value)}
        />
        <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
          Remove
        </button>
      </div>
    ));
  };

  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  return (
    <div className="jil-cmd-editor">
      <div className="jil-job-header">
        <span>CMD Job</span>
        <div className="jil-header-actions">
          {path.length > 1 && (
            <button className="jil-remove-job-btn" onClick={() => onRemoveJob && onRemoveJob()}>
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-cmd-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
    </div>
  );
};

export default JILCmdEditor;


---

6. JILFwEditor.jsx

import React, { useState } from "react";

const JILFwEditor = ({ schema, definitions, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  const renderKeyValuePairs = () => {
    return Object.keys(data).map((key, idx) => (
      <div key={idx} className="jil-keyvalue-row">
        <label>{key}: </label>
        <input
          className="jil-input"
          type="text"
          value={data[key]}
          onChange={(e) => handleChange(key, e.target.value)}
        />
        <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
          Remove
        </button>
      </div>
    ));
  };

  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  return (
    <div className="jil-fw-editor">
      <div className="jil-job-header">
        <span>File Watcher Job (FW)</span>
        <div className="jil-header-actions">
          {path.length > 1 && (
            <button className="jil-remove-job-btn" onClick={() => onRemoveJob && onRemoveJob()}>
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-fw-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
    </div>
  );
};

export default JILFwEditor;


---

7. JILUtils.js

// Converts the internal JSON structure into a formatted JIL file text.
export const convertToJILText = (jilJson) => {
  // Recursive function to format a job.
  const formatJob = (job) => {
    // Create a header comment with dashed lines and the job's insert_job value.
    const jobName = job.insert_job || "Unknown Job";
    let output = `/*----------------- ${jobName} ------------------*/\n\n`;
    // Format each key-value pair.
    Object.keys(job).forEach((key) => {
      if (key !== "properties") {
        output += `${key}: ${job[key]}  `;
        // If the key is job_type, add a line break.
        if (key === "job_type") output += "\n";
        else output += "\n";
      }
    });
    output += "\n";
    // If there are child jobs, format them recursively.
    if (job.properties && Array.isArray(job.properties)) {
      job.properties.forEach((childJob) => {
        output += formatJob(childJob);
        output += "\n";
      });
    }
    return output;
  };

  // Start with the mainBox.
  return formatJob(jilJson.mainBox);
};

// Helper function to fill defaults based on a given schema.
// This version iterates over schema.properties and uses default if available.
export const fillDefaults = (schema) => {
  const defaults = {};
  if (schema && schema.properties) {
    Object.keys(schema.properties).forEach((key) => {
      const prop = schema.properties[key];
      defaults[key] = prop.default !== undefined ? prop.default : "";
    });
  }
  return defaults;
};

// Create a default JIL file using the provided definitions from metadata.
// This function uses the defaults defined in definitions for MainBOX and CMD.
export const createDefaultJILFile = (definitions) => {
  return {
    mainBox: {
      ...fillDefaults(definitions.MainBOX),
      // Set properties array with one default CMD job.
      properties: [
        { 
          ...fillDefaults(definitions.CMD),
          job_type: "CMD"
        }
      ]
    }
  };
};


---

8. JILEditorContext.jsx

import React, { createContext } from "react";

export const JILEditorContext = createContext();

export const JILEditorProvider = JILEditorContext.Provider;


---

9. JILEditor.css

/* Container & Global Styles */
.jil-editor-container {
  margin: 20px;
  font-family: Arial, sans-serif;
}

.jil-navigation {
  margin-bottom: 10px;
}

.jil-navigation button {
  margin-right: 5px;
}

.jil-delete-file-btn {
  background-color: #e57373;
  color: white;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
}

.jil-delete-file-btn:hover {
  background-color: #ef5350;
}

/* Editor Layout */
.jil-editor {
  display: flex;
  flex-direction: column;
}

.jil-editor-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.jil-editor-body {
  display: flex;
  margin-top: 10px;
  height: 500px; /* set a fixed height so both panels are equal */
}

.jil-editor-left,
.jil-editor-right {
  width: 50%;
  padding: 10px;
  box-sizing: border-box;
}

/* Scroll container so the scroll bar appears below the heading */
.scroll-container {
  height: 100%;
  display: flex;
  flex-direction: column;
}

.scroll-container h4 {
  margin: 0 0 10px 0;
}

.scroll-content {
  flex: 1;
  overflow-y: auto;
}

/* Live preview styling */
.jil-editor-right textarea {
  width: 100%;
  height: 100%;
  box-sizing: border-box;
}

/* Job Editor Styles */
.jil-box-editor,
.jil-cmd-editor,
.jil-fw-editor {
  border: 1px solid #ccc;
  padding: 10px;
  margin-bottom: 10px;
}

.jil-job-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background-color: #f2f2f2;
  padding: 5px;
  margin-bottom: 10px;
}

.jil-header-actions {
  display: flex;
  align-items: center;
}

.jil-job-dropdown {
  margin-right: 10px;
}

.jil-remove-job-btn {
  background-color: #e57373;
  color: white;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
}

.jil-remove-job-btn:hover {
  background-color: #ef5350;
}

/* Key-Value Row Styles */
.jil-keyvalue-row {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
}

.jil-keyvalue-row label {
  width: 100px; /* smaller than input width */
  color: black; /* key color: black */
  font-weight: bold;
}

.jil-input {
  width: 350px; /* increased width */
  padding: 4px;
  margin-right: 10px;
}

.jil-remove-btn {
  background-color: #e57373;
  color: white;
  border: none;
  padding: 2px 6px;
  cursor: pointer;
}

.jil-remove-btn:hover {
  background-color: #ef5350;
}

/* New Pair Inline Section */
.jil-new-pair-row {
  display: flex;
  align-items: center;
  margin-top: 10px;
}

.jil-add-btn {
  background-color: #81c784;
  color: white;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
  margin-left: 10px;
}

.jil-add-btn:hover {
  background-color: #66bb6a;
}

.jil-add-pair-btn {
  background-color: #64b5f6;
  color: white;
  border: none;
  padding: 4px 8px;
  cursor: pointer;
  margin-top: 10px;
}

.jil-add-pair-btn:hover {
  background-color: #42a5f5;
}

/* Child Jobs Section */
.jil-child-job {
  margin-left: 20px;
  margin-top: 10px;
}

.jil-child-section h5 {
  margin-bottom: 5px;
}


---

Final Remarks

Default New File Structure: When “Add File” is pressed in the navigation, JILEditorContainer now uses the helper function in jilUtils.js (createDefaultJILFile) to create a default file that has a main box with one CMD job, using defaults from metadata.definitions.

Raw Preview: The convertToJILText function in jilUtils.js formats each job with a comment header and key–value pairs, mimicking your sample.

File Deletion: A “Delete File” button is added in the navigation (JILNavigation.jsx) that removes the current file.

UI Consistency: The left (structured editor) panel now has an inner scroll container so that its scroll bar starts below the heading, matching the live preview. Input widths have been increased and key labels are styled in black.


These files should now implement your current requirements as well as provide a basis for future enhancements. Let me know if you have any questions or further adjustments!

