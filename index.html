Below is an explanation of our updated strategy and the changes that have been applied—and then the full updated files (only those that have ordering changes):

Strategy Recap

1. Extracting Ordered Keys from Metadata:
We add a helper function (getOrderedKeys) that extracts keys in the order defined in the metadata’s schema for a given job type.
• In each job editor (BOX, CMD, and FW), instead of iterating over Object.keys(data) directly, we first retrieve the ordered keys from the corresponding schema (i.e. schema.properties), then render rows for those keys if present in the data.
• After that, if any custom (user-added) keys exist in the data (keys not found in the metadata), we render them afterward (e.g. appended at the end).


2. Applying Ordering in the Raw Preview Conversion:
In our conversion function (convertToJILText) we now attempt to output keys in the correct order. For each job, we: • Identify the job’s type (using its job_type field) to look up the appropriate schema from the definitions provided in context. • Then we iterate over the ordered keys from that schema, outputting each key–value pair in order.
• Finally, we append any custom keys (if found).


3. Consistency Across Left and Right Panels:
By using the same helper and the same ordering logic in both the job editors (structured view) and in the raw preview conversion, we ensure that the ordering is identical.




---

Below are the full updated files that have been changed to implement ordering. (Other files remain unchanged.)


---

Updated JILUtils.js

// Converts the internal JSON structure into formatted JIL text using ordering from metadata.
export const convertToJILText = (jilJson, definitions) => {
  // Helper: get ordered keys from a schema's properties.
  const getOrderedKeys = (schema) => {
    if (schema && schema.properties) {
      return Object.keys(schema.properties);
    }
    return [];
  };

  // Helper: format a single job recursively.
  const formatJob = (job, schema) => {
    // Determine the job name.
    const jobName = job.insert_job || "Unknown Job";
    let output = `/*----------------- ${jobName} ------------------*/\n\n`;

    // Determine the appropriate definition based on job_type.
    let defSchema;
    if (!schema) {
      // Fallback: decide by job_type using definitions parameter.
      if (job.job_type === "BOX") {
        defSchema = definitions.MainBOX; // top-level mainBox or SubBOX if nested
      } else if (job.job_type === "CMD") {
        defSchema = definitions.CMD;
      } else if (job.job_type === "FW") {
        defSchema = definitions.FW;
      } else {
        defSchema = {};
      }
    } else {
      defSchema = schema;
    }

    // Get ordered keys from the definition.
    const orderedKeys = (defSchema && defSchema.properties)
      ? Object.keys(defSchema.properties)
      : [];
    // Render keys defined in metadata first.
    orderedKeys.forEach((key) => {
      // Skip the "properties" key since that holds children.
      if (key === "properties") return;
      if (job.hasOwnProperty(key)) {
        output += `${key}: ${job[key]}\n`;
      }
    });
    // Append any custom keys (those present in job but not in orderedKeys).
    Object.keys(job)
      .filter((key) => key !== "properties" && !orderedKeys.includes(key))
      .forEach((key) => {
        output += `${key}: ${job[key]}\n`;
      });
    output += "\n";
    // Recursively process child jobs if any.
    if (job.properties && Array.isArray(job.properties)) {
      job.properties.forEach((child) => {
        // For children of a BOX job, decide: if job_type is BOX then use SubBOX definition; else use corresponding definitions.
        let childDef;
        if (child.job_type === "BOX") {
          childDef = definitions.SubBOX;
        } else if (child.job_type === "CMD") {
          childDef = definitions.CMD;
        } else if (child.job_type === "FW") {
          childDef = definitions.FW;
        }
        output += formatJob(child, childDef) + "\n";
      });
    }
    return output;
  };

  // Start conversion using mainBox.
  return formatJob(jilJson.mainBox, definitions.MainBOX);
};

// Helper to fill defaults based on the given schema.
export const fillDefaults = (schema) => {
  const defaults = {};
  if (schema && schema.properties) {
    Object.keys(schema.properties).forEach((key) => {
      const prop = schema.properties[key];
      defaults[key] = prop.default !== undefined ? prop.default : "";
    });
  }
  return defaults;
};

// Create a default JIL file using provided definitions.
// It creates a main box from definitions.MainBOX and one default CMD job from definitions.CMD.
export const createDefaultJILFile = (definitions) => {
  return {
    mainBox: {
      ...fillDefaults(definitions.MainBOX),
      properties: [
        {
          ...fillDefaults(definitions.CMD),
          job_type: "CMD"
        }
      ]
    }
  };
};


---

Updated JILBoxEditor.jsx

import React, { useState } from "react";
import JILFieldRenderer from "./JILFieldRenderer";
import { fillDefaults } from "./jilUtils";

const JILBoxEditor = ({ schema, definitions, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  // Helper: get ordered keys from schema definition for this job type.
  const getOrderedKeys = () => {
    if (schema && schema.properties) {
      return Object.keys(schema.properties);
    }
    return [];
  };

  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  // Render keys according to metadata order, then custom keys.
  const renderKeyValuePairs = () => {
    const orderedKeys = getOrderedKeys();
    const rendered = [];

    // Render defined keys in order, except "properties"
    orderedKeys.forEach((key) => {
      if (key === "properties") return;
      if (data.hasOwnProperty(key)) {
        rendered.push(
          <div key={key} className="jil-keyvalue-row">
            <label>{key}: </label>
            <input
              className="jil-input"
              type="text"
              value={data[key]}
              onChange={(e) => handleChange(key, e.target.value)}
            />
            <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
              Remove
            </button>
          </div>
        );
      }
    });
    // Render additional keys not in the metadata order (custom keys)
    Object.keys(data)
      .filter((key) => key !== "properties" && !orderedKeys.includes(key))
      .forEach((key) => {
        rendered.push(
          <div key={key} className="jil-keyvalue-row">
            <label>{key}: </label>
            <input
              className="jil-input"
              type="text"
              value={data[key]}
              onChange={(e) => handleChange(key, e.target.value)}
            />
            <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
              Remove
            </button>
          </div>
        );
      });
    return rendered;
  };

  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  const handleChildChange = (index, childData) => {
    const newProperties = data.properties ? [...data.properties] : [];
    newProperties[index] = childData;
    handleChange("properties", newProperties);
  };

  const addChildJob = (jobType) => {
    let newJob = {};
    if (jobType === "BOX") {
      newJob = fillDefaults(definitions.SubBOX);
    } else if (jobType === "CMD") {
      newJob = fillDefaults(definitions.CMD);
    } else if (jobType === "FW") {
      newJob = fillDefaults(definitions.FW);
    }
    newJob.job_type = jobType;
    if (jobType === "BOX") newJob.properties = [];
    const newProperties = data.properties ? [...data.properties, newJob] : [newJob];
    handleChange("properties", newProperties);
  };

  const renderChildJobs = () => {
    const children = data.properties || [];
    return children.map((child, index) => (
      <div key={index} className="jil-child-job">
        <JILFieldRenderer
          schema={child.job_type === "BOX" ? definitions.SubBOX : {}}
          definitions={definitions}
          data={child}
          path={[...path, "properties", index]}
          onFieldChange={(childData) => handleChildChange(index, childData)}
          onRemoveJob={() => {
            const newProperties = data.properties.filter((_, idx) => idx !== index);
            handleChange("properties", newProperties);
          }}
        />
      </div>
    ));
  };

  return (
    <div className="jil-box-editor">
      <div className="jil-job-header">
        <span>{path[0] === "mainBox" && path.length === 1 ? "Main Box Job" : "Sub Box"}</span>
        <div className="jil-header-actions">
          <select
            className="jil-job-dropdown"
            onChange={(e) => {
              if (e.target.value) {
                addChildJob(e.target.value);
                e.target.value = "";
              }
            }}
          >
            <option value="">Add Child Job...</option>
            <option value="BOX">Sub Box</option>
            <option value="CMD">CMD</option>
            <option value="FW">FW</option>
          </select>
          {path.length > 1 && (
            <button className="jil-remove-job-btn" onClick={() => onRemoveJob && onRemoveJob()}>
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-box-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
      <div className="jil-child-section">
        <h5>Child Jobs</h5>
        {renderChildJobs()}
      </div>
    </div>
  );
};

export default JILBoxEditor;


---

Updated JILCmdEditor.jsx

import React, { useState } from "react";

const JILCmdEditor = ({ schema, definitions, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  const getOrderedKeys = () => {
    if (schema && schema.properties) {
      return Object.keys(schema.properties);
    }
    return [];
  };

  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  const renderKeyValuePairs = () => {
    const orderedKeys = getOrderedKeys();
    const rendered = [];

    // Render keys defined in metadata
    orderedKeys.forEach((key) => {
      if (data.hasOwnProperty(key)) {
        rendered.push(
          <div key={key} className="jil-keyvalue-row">
            <label>{key}: </label>
            <input
              className="jil-input"
              type="text"
              value={data[key]}
              onChange={(e) => handleChange(key, e.target.value)}
            />
            <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
              Remove
            </button>
          </div>
        );
      }
    });
    // Render custom keys not defined in schema.
    Object.keys(data)
      .filter((key) => !orderedKeys.includes(key))
      .forEach((key) => {
        rendered.push(
          <div key={key} className="jil-keyvalue-row">
            <label>{key}: </label>
            <input
              className="jil-input"
              type="text"
              value={data[key]}
              onChange={(e) => handleChange(key, e.target.value)}
            />
            <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
              Remove
            </button>
          </div>
        );
      });
    return rendered;
  };

  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  return (
    <div className="jil-cmd-editor">
      <div className="jil-job-header">
        <span>CMD Job</span>
        <div className="jil-header-actions">
          {path.length > 1 && (
            <button className="jil-remove-job-btn" onClick={() => onRemoveJob && onRemoveJob()}>
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-cmd-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
    </div>
  );
};

export default JILCmdEditor;


---

Updated JILFwEditor.jsx

import React, { useState } from "react";

const JILFwEditor = ({ schema, definitions, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPair, setShowNewPair] = useState(false);
  const [newKey, setNewKey] = useState("");
  const [newValue, setNewValue] = useState("");

  const getOrderedKeys = () => {
    if (schema && schema.properties) {
      return Object.keys(schema.properties);
    }
    return [];
  };

  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  const renderKeyValuePairs = () => {
    const orderedKeys = getOrderedKeys();
    const rendered = [];

    orderedKeys.forEach((key) => {
      if (data.hasOwnProperty(key)) {
        rendered.push(
          <div key={key} className="jil-keyvalue-row">
            <label>{key}: </label>
            <input
              className="jil-input"
              type="text"
              value={data[key]}
              onChange={(e) => handleChange(key, e.target.value)}
            />
            <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
              Remove
            </button>
          </div>
        );
      }
    });
    Object.keys(data)
      .filter((key) => !orderedKeys.includes(key))
      .forEach((key) => {
        rendered.push(
          <div key={key} className="jil-keyvalue-row">
            <label>{key}: </label>
            <input
              className="jil-input"
              type="text"
              value={data[key]}
              onChange={(e) => handleChange(key, e.target.value)}
            />
            <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
              Remove
            </button>
          </div>
        );
      });
    return rendered;
  };

  const renderNewPairSection = () => {
    if (!showNewPair) {
      return (
        <button className="jil-add-pair-btn" onClick={() => setShowNewPair(true)}>
          Add New Pair
        </button>
      );
    }
    return (
      <div className="jil-new-pair-row">
        <input
          className="jil-input"
          type="text"
          placeholder="Key"
          value={newKey}
          onChange={(e) => setNewKey(e.target.value)}
        />
        <input
          className="jil-input"
          type="text"
          placeholder="Value"
          value={newValue}
          onChange={(e) => setNewValue(e.target.value)}
        />
        <button
          className="jil-add-btn"
          onClick={() => {
            if (newKey) {
              handleChange(newKey, newValue);
              setNewKey("");
              setNewValue("");
              setShowNewPair(false);
            }
          }}
        >
          Add
        </button>
      </div>
    );
  };

  return (
    <div className="jil-fw-editor">
      <div className="jil-job-header">
        <span>File Watcher Job (FW)</span>
        <div className="jil-header-actions">
          {path.length > 1 && (
            <button className="jil-remove-job-btn" onClick={() => onRemoveJob && onRemoveJob()}>
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-fw-content">
        {renderKeyValuePairs()}
        {renderNewPairSection()}
      </div>
    </div>
  );
};

export default JILFwEditor;


---

Final Comments

• In each job editor we now use a helper (getOrderedKeys) to iterate over keys from the metadata (the schema passed in) so that ordering follows the defined order.
• We then render any keys from the data that aren’t in that order as extra custom keys after the ordered ones.
• The conversion function in jilUtils.js now uses similar logic to print the JIL text in the correct order.
• The container and editor files now pass along metadata definitions as needed for ordering.

These updates should now implement the required ordering in both the structured editor (left side) and the raw preview (right side). Let me know if any further adjustments are needed!

