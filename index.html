import React, { useState } from "react";
import PropTypes from "prop-types";
import JILFieldRenderer from "./JILFieldRenderer";
import { fillDefaults } from "./JILUtils";

const JILBoxEditor = ({ schema, definitions, data, path, onFieldChange, onRemoveJob }) => {
  const [showNewPairDropdown, setShowNewPairDropdown] = useState(false);

  const getOrderedKeys = () =>
    schema && schema.properties ? Object.keys(schema.properties).filter((key) => key !== "properties") : [];

  const handleChange = (key, value) => {
    const newData = { ...data, [key]: value };
    onFieldChange(newData);
  };

  const removeKeyValuePair = (key) => {
    const newData = { ...data };
    delete newData[key];
    onFieldChange(newData);
  };

  const getAvailableKeys = () => {
    const ordered = getOrderedKeys();
    return ordered.filter((key) => !data.hasOwnProperty(key));
  };

  const renderKeyValuePairs = () => {
    const orderedKeys = getOrderedKeys();
    const rendered = [];
    orderedKeys.forEach((key) => {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        rendered.push(
          <div key={`kv-${key}`} className="jil-keyvalue-row">
            <label>{key}: </label>
            <input
              className="jil-input"
              type="text"
              value={data[key]}
              onChange={(e) => handleChange(key, e.target.value)}
            />
            <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
              Remove
            </button>
          </div>
        );
      }
    });
    Object.keys(data)
      .filter((key) => key !== "properties" && !orderedKeys.includes(key))
      .forEach((key) => {
        rendered.push(
          <div key={`extra-${key}`} className="jil-keyvalue-row">
            <label>{key}: </label>
            <input
              className="jil-input"
              type="text"
              value={data[key]}
              onChange={(e) => handleChange(key, e.target.value)}
            />
            <button className="jil-remove-btn" onClick={() => removeKeyValuePair(key)}>
              Remove
            </button>
          </div>
        );
      });
    return rendered;
  };

  const renderNewPairDropdown = () => {
    const available = getAvailableKeys();
    if (available.length === 0) return null;
    return (
      <select
        className="jil-add-pair-dropdown"
        onChange={(e) => {
          if (e.target.value) {
            handleChange(e.target.value, "");
            setShowNewPairDropdown(false);
          }
        }}
      >
        <option value="">Select key to add</option>
        {available.map((key) => (
          <option key={key} value={key}>
            {key}
          </option>
        ))}
      </select>
    );
  };

  const handleChildChange = (index, childData) => {
    const newProperties = data.properties ? [...data.properties] : [];
    newProperties[index] = childData;
    handleChange("properties", newProperties);
  };

  /**
   * Enhanced addChildJob:
   * - For CMD jobs, copy specific fields from the parent's initial CMD job.
   * - For BOX jobs, copy specific fields from the parent (main box).
   * In either case, set the job's insert_job to empty.
   */
  const addChildJob = (jobType) => {
    let newJob = {};
    if (jobType === "BOX") {
      newJob = fillDefaults(definitions.SubBOX);
      // Prepopulate BOX fields from parent's data.
      newJob.owner = data.owner || "";
      newJob.permission = data.permission || "";
      newJob.date_conditions = data.date_conditions || "";
      newJob.condition = data.condition || "";
      newJob.description = data.description || "";
      newJob.alarm_if_fail = data.alarm_if_fail || "";
      newJob.alarm_if_terminated = data.alarm_if_terminated || "";
      newJob.group = data.group || "";
      newJob.application = data.application || "";
      newJob.insert_job = "";
    } else if (jobType === "CMD") {
      newJob = fillDefaults(definitions.CMD);
      // Prepopulate from the parent's initial CMD job (assumed to be at index 0 in properties).
      const parentCmdJob = (data.properties || []).find((prop) => prop.job_type === "CMD") || {};
      const fieldsToCopy = [
        "machine",
        "owner",
        "permission",
        "date_conditions",
        "condition",
        "description",
        "std_out_file",
        "std_err_file",
        "alarm_if_fail",
        "profile",
        "job_load",
        "priority",
        "alarm_if_terminated",
        "timezone",
        "group",
        "application",
        "success_codes",
        "fail_codes"
      ];
      fieldsToCopy.forEach((field) => {
        newJob[field] = parentCmdJob[field] || "";
      });
      // Ensure insert_job and command are left empty
      newJob.insert_job = "";
      newJob.command = "";
    } else if (jobType === "FW") {
      newJob = fillDefaults(definitions.FW);
      // For FW, simply set box_name as parent's name (no additional prepopulation requested)
    }
    newJob.job_type = jobType;
    // Set the new job's box_name to the parent's insert_job.
    const parentJobName = data.insert_job || "";
    newJob.box_name = parentJobName;
    if (jobType === "BOX") newJob.properties = [];
    const newProperties = data.properties ? [...data.properties, newJob] : [newJob];
    handleChange("properties", newProperties);
  };

  // Helper: Render each child job, using a combination of insert_job and index for a unique key.
  const renderChildJob = (child, index) => {
    const key = child.insert_job ? `${child.insert_job}-${index}` : `child-${index}`;
    return (
      <div key={key} className="jil-child-job">
        <JILFieldRenderer
          schema={child.job_type === "BOX" ? definitions.SubBOX : {}}
          definitions={definitions}
          data={child}
          path={[...path, "properties", String(index)]}
          onFieldChange={(childData) => handleChildChange(index, childData)}
          onRemoveJob={() => {
            const newProperties = data.properties.filter((_, idx) => idx !== index);
            handleChange("properties", newProperties);
          }}
        />
      </div>
    );
  };

  const renderChildJobs = () => {
    const children = data.properties || [];
    return children.map((child, index) => renderChildJob(child, index));
  };

  return (
    <div className="jil-box-editor">
      <div className="jil-job-header">
        <span>{path[0] === "mainBox" && path.length === 1 ? "Main Box Job" : "Sub Box"}</span>
        <div className="jil-header-actions">
          <select
            className="jil-job-dropdown"
            onChange={(e) => {
              if (e.target.value) {
                addChildJob(e.target.value);
                e.target.value = "";
              }
            }}
          >
            <option value="">Add Child Job...</option>
            <option value="BOX">Sub Box</option>
            <option value="CMD">CMD</option>
            <option value="FW">FW</option>
          </select>
          {path.length > 1 && (
            <button className="jil-remove-job-btn" onClick={() => onRemoveJob && onRemoveJob()}>
              Remove Job
            </button>
          )}
        </div>
      </div>
      <div className="jil-box-content">
        {renderKeyValuePairs()}
        {renderNewPairDropdown()}
      </div>
      <div className="jil-child-section">{renderChildJobs()}</div>
    </div>
  );
};

JILBoxEditor.propTypes = {
  schema: PropTypes.object.isRequired,
  definitions: PropTypes.object.isRequired,
  data: PropTypes.object.isRequired,
  path: PropTypes.arrayOf(PropTypes.string).isRequired,
  onFieldChange: PropTypes.func.isRequired,
  onRemoveJob: PropTypes.func
};

export default JILBoxEditor;
