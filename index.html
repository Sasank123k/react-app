Below is an updated version of the React component that follows your companyâ€™s guidelines. In this version, we:

- Import a constant called **MICROSERVICE_URL** (which should contain your backend URL plus the API path).  
- Import a helper **generateSearHeaders** that produces the required headers for API calls.  
- Use these in every fetch call (GET and POST).

You can adjust the import paths as needed based on your project structure.

---

### SqlEditorPage.jsx

```jsx
import React, { useEffect, useState } from 'react';
import AceEditor from 'react-ace';
import sqlFormatter from 'sql-formatter';
import 'ace-builds/src-noconflict/mode-sql';
import 'ace-builds/src-noconflict/theme-github';
import './SqlEditorPage.css';

// Import company-specific constants and helpers
import { MICROSERVICE_URL, generateSearHeaders } from 'config'; // Update this path as per your project structure

function SqlEditorPage() {
  // For demonstration we hardcode the requirement id.
  const requirementId = "BZLS-4501";

  // State for storing both SQL file contents.
  const [sqlFiles, setSqlFiles] = useState({
    createSqlContent: '',
    deleteSqlContent: ''
  });

  // State for the active file in the editor. Possible values: "create" or "delete"
  const [activeFile, setActiveFile] = useState('create');
  const [editorContent, setEditorContent] = useState('');
  const [loading, setLoading] = useState(true);

  // Fetch SQL files from the backend on component mount.
  useEffect(() => {
    const url = `${MICROSERVICE_URL}/api/sql/${requirementId}`;
    fetch(url, {
      method: 'GET',
      headers: generateSearHeaders()
    })
      .then(response => response.json())
      .then(data => {
        // Auto-format the SQL files using sql-formatter on initial load.
        const formattedCreate = sqlFormatter.format(data.createSqlContent);
        const formattedDelete = sqlFormatter.format(data.deleteSqlContent);

        const files = {
          createSqlContent: formattedCreate,
          deleteSqlContent: formattedDelete
        };

        setSqlFiles(files);
        setEditorContent(formattedCreate);
        setLoading(false);
      })
      .catch(error => {
        console.error("Error fetching SQL files:", error);
        setLoading(false);
      });
  }, [requirementId]);

  // Handle drop-down file selection change.
  const handleFileChange = (event) => {
    const selected = event.target.value;
    setActiveFile(selected);
    if (selected === 'create') {
      setEditorContent(sqlFiles.createSqlContent);
    } else {
      setEditorContent(sqlFiles.deleteSqlContent);
    }
  };

  // Handle editor content changes.
  const handleEditorChange = (newValue) => {
    setEditorContent(newValue);
    setSqlFiles(prevState => {
      return activeFile === 'create'
        ? { ...prevState, createSqlContent: newValue }
        : { ...prevState, deleteSqlContent: newValue };
    });
  };

  // Format the current editor content using sql-formatter.
  const handleFormat = () => {
    const formattedContent = sqlFormatter.format(editorContent);
    setEditorContent(formattedContent);
    setSqlFiles(prevState => {
      return activeFile === 'create'
        ? { ...prevState, createSqlContent: formattedContent }
        : { ...prevState, deleteSqlContent: formattedContent };
    });
  };

  // Save the SQL files after formatting both and calling the update endpoint.
  const handleSave = () => {
    // Format both SQL contents before saving.
    const formattedCreate = sqlFormatter.format(sqlFiles.createSqlContent);
    const formattedDelete = sqlFormatter.format(sqlFiles.deleteSqlContent);
    const updatedFiles = {
      createSqlContent: formattedCreate,
      deleteSqlContent: formattedDelete
    };

    // Update the active editor.
    if (activeFile === 'create') {
      setEditorContent(formattedCreate);
    } else {
      setEditorContent(formattedDelete);
    }

    const url = `${MICROSERVICE_URL}/api/sql/${requirementId}`;
    fetch(url, {
      method: 'POST',
      headers: {
        ...generateSearHeaders(),
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(updatedFiles)
    })
      .then(response => {
        if (!response.ok) {
          throw new Error('Failed to update SQL files');
        }
        return response.json();
      })
      .then(data => {
        alert('SQL files updated successfully.');
      })
      .catch(error => {
        console.error("Error saving SQL files:", error);
        alert('Error updating SQL files. Please try again.');
      });
  };

  if (loading) {
    return <div>Loading SQL editor...</div>;
  }

  return (
    <div className="sql-editor-page">
      <div className="toolbar">
        <select value={activeFile} onChange={handleFileChange}>
          <option value="create">Create SQL</option>
          <option value="delete">Delete SQL</option>
        </select>
        <button onClick={handleFormat}>Format</button>
        <button onClick={handleSave}>Save</button>
      </div>
      <AceEditor
        mode="sql"
        theme="github"
        name="sql-editor"
        value={editorContent}
        onChange={handleEditorChange}
        width="100%"
        height="500px"
        setOptions={{
          enableBasicAutocompletion: true,
          enableLiveAutocompletion: true,
        }}
      />
    </div>
  );
}

export default SqlEditorPage;
```

---

### SqlEditorPage.css

```css
.sql-editor-page {
  margin: 20px;
  padding: 20px;
  font-family: Arial, sans-serif;
}

.toolbar {
  display: flex;
  align-items: center;
  margin-bottom: 10px;
}

.toolbar select {
  margin-right: 10px;
  padding: 5px;
  font-size: 14px;
}

.toolbar button {
  margin-right: 10px;
  padding: 5px 10px;
  font-size: 14px;
  cursor: pointer;
  border: 1px solid #ccc;
  background-color: #f5f5f5;
}

.toolbar button:hover {
  background-color: #e0e0e0;
}
```

---

### Guidelines Followed

1. **Backend URL Usage:**  
   The code uses the imported **MICROSERVICE_URL** constant to construct API endpoint URLs.

2. **Header Generation:**  
   Both GET and POST calls include the headers from **generateSearHeaders**, ensuring that the common header requirements are met.

3. **Content-Type Header:**  
   For POST requests, a `Content-Type: application/json` header is added along with the generated headers.

4. **Consistent Fetch Structure:**  
   The code follows a consistent pattern for asynchronous data fetching and error handling.

5. **Formatting Before Updates:**  
   The code formats the SQL content before saving, both in the current editor and across both files.

You can now adjust the import paths and other small details as per your company's configuration and code style guidelines. Let me know if you need additional refinements or further details!
