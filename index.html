Below is the full set of files for Phase 3 (the action handlers) and Phase 4 (file navigation and live preview) for your JIL editor. These files use the same conventions (including CSS class names prefixed with “jileditor-”) as the Phase 1/2 files, and assume that you’ve already set up your context (JilEditorContext) and utility functions (in jilPathUtils.js).


---

Phase 3 – Action Handlers

These functions will be used to update the JIL files’ state as the user interacts with the form.

File: JilEditor/jilActions.js

// File: JilEditor/jilActions.js
// Import necessary helpers from your utility file
import { 
  buildInitialData, 
  navigateCursor, 
  buildOrCloneItem, 
  incrementIDs, 
  orderObjectBySchema, 
  getMissingFields 
} from "./jilPathUtils";

/**
 * Updates a primitive field value.
 */
export const handleFieldChange = (jilFiles, setJilFiles, pathArray, newValue) => {
  const dataCopy = JSON.parse(JSON.stringify(jilFiles));
  let cursor = dataCopy;
  for (let i = 0; i < pathArray.length - 1; i++) {
    const key = pathArray[i];
    if (cursor[key] === undefined) cursor[key] = {};
    cursor = cursor[key];
  }
  cursor[pathArray[pathArray.length - 1]] = newValue;
  setJilFiles(dataCopy);
};

/**
 * Adds an optional property to an object.
 */
export const handleAddOptionalProperty = (jilFiles, setJilFiles, pathArray, propertyName, propSchema) => {
  const dataCopy = JSON.parse(JSON.stringify(jilFiles));
  let cursor = dataCopy;
  for (let i = 0; i < pathArray.length; i++) {
    const key = pathArray[i];
    if (cursor[key] === undefined) cursor[key] = {};
    cursor = cursor[key];
  }
  if (cursor[propertyName] === undefined) {
    cursor[propertyName] = buildInitialData(propSchema);
  }
  setJilFiles(dataCopy);
};

/**
 * Adds an item to an array (e.g. nested jobs).
 */
export const handleAddArrayItem = (jilFiles, setJilFiles, pathArray, itemSchema) => {
  const dataCopy = JSON.parse(JSON.stringify(jilFiles));
  let cursor = navigateCursor(dataCopy, pathArray);
  if (!Array.isArray(cursor)) return;
  let newItem = buildOrCloneItem(cursor, itemSchema);
  incrementIDs(newItem);
  cursor.push(newItem);
  setJilFiles(dataCopy);
};

/**
 * Removes an item from an array.
 */
export const handleRemoveArrayItem = (jilFiles, setJilFiles, pathArray, index) => {
  const dataCopy = JSON.parse(JSON.stringify(jilFiles));
  let cursor = dataCopy;
  for (let i = 0; i < pathArray.length; i++) {
    const key = pathArray[i];
    if (cursor[key] === undefined) return;
    cursor = cursor[key];
  }
  if (!Array.isArray(cursor)) return;
  if (index < 0 || index >= cursor.length) return;
  cursor.splice(index, 1);
  setJilFiles(dataCopy);
};

/**
 * Replaces data at a given path with a new object.
 */
export const handleReplaceData = (jilFiles, setJilFiles, pathArray, newObject) => {
  const dataCopy = JSON.parse(JSON.stringify(jilFiles));
  let cursor = dataCopy;
  for (let i = 0; i < pathArray.length - 1; i++) {
    const key = pathArray[i];
    if (!cursor[key]) cursor[key] = {};
    cursor = cursor[key];
  }
  cursor[pathArray[pathArray.length - 1]] = newObject;
  setJilFiles(dataCopy);
};

/**
 * Downloads the current JIL file as a JSON file.
 */
export const handleDownload = (jilFiles, metaData, key, requirementId) => {
  const orderedData = {
    [key]: orderObjectBySchema(jilFiles[key], metaData[key]),
  };

  const missing = getMissingFields(orderedData[key], metaData[key], key);
  if (missing.length > 0) {
    alert("The following required fields are missing or empty:\n" + missing.join("\n"));
    return;
  }

  const blob = new Blob([JSON.stringify(orderedData, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const link = document.createElement("a");
  link.href = url;
  link.download = `jilData_${requirementId}.json`;
  link.click();
  URL.revokeObjectURL(url);
};


---

Phase 4 – File Navigation and Live Preview

These components allow users to switch between multiple JIL files and view a live preview.

File: JilEditor/JilFileNavigation.jsx

// File: JilEditor/JilFileNavigation.jsx
import React, { useContext } from "react";
import { JilEditorContext } from "./JilEditorContext";
import "./JilEditor.css";

export default function JilFileNavigation() {
  const { jilFiles, activeIndex, setActiveIndex, setJilFiles } = useContext(JilEditorContext);

  // Helper to create a new default JIL file
  const createNewJilFile = () => {
    return {
      mainBox: {
        insert_job: "<job name>",
        job_type: "BOX",
        owner: "<owner name>",
        permission: "me,mx,ge,gx,we,wx",
        date_condition: 0,
        description: "<description>",
        alarm_if_fail: 0,
        alarm_if_terminated: 0,
        timezone: "US/Pacific",
        group: "<group name>",
        application: "<app name>",
        properties: [
          {
            insert_job: "<job name>",
            job_type: "CMD",
            box_name: "<parent box job name>",
            command: "<command>",
            machine: "<machine name>",
            owner: "<owner name>",
            permission: "me,mx,ge,gx,we,wx",
            date_condition: 0,
            condition: "<condition>",
            description: "<description>",
            std_out_file: "<filename>",
            std_err_file: "<filename>",
            alarm_if_fail: 1,
            profile: "<profile name>",
            job_load: 30,
            priority: 290,
            alarm_if_terminated: 1,
            timezone: "US/Pacific",
            group: "<group name>",
            application: "<app name>",
          },
        ],
      },
    };
  };

  const handleAddNew = () => {
    const newFile = createNewJilFile();
    setJilFiles([...jilFiles, newFile]);
    setActiveIndex(jilFiles.length); // New file becomes active
  };

  const handlePrev = () => {
    if (activeIndex > 0) {
      setActiveIndex(activeIndex - 1);
    }
  };

  const handleNext = () => {
    if (activeIndex < jilFiles.length - 1) {
      setActiveIndex(activeIndex + 1);
    }
  };

  return (
    <div className="jileditor-fileNavigation">
      <button className="jileditor-button" onClick={handlePrev}>Prev</button>
      <span className="jileditor-activeIndicator">
        File {activeIndex + 1} of {jilFiles.length}
      </span>
      <button className="jileditor-button" onClick={handleNext}>Next</button>
      <button className="jileditor-button" onClick={handleAddNew}>Add New File</button>
    </div>
  );
}


---

File: JilEditor/JilLivePreview.jsx

// File: JilEditor/JilLivePreview.jsx
import React, { useContext, useEffect, useState } from "react";
import { JilEditorContext } from "./JilEditorContext";
import "./JilEditor.css";

export default function JilLivePreview() {
  const { jilFiles, activeIndex } = useContext(JilEditorContext);
  const [rawPreview, setRawPreview] = useState("");

  useEffect(() => {
    if (jilFiles.length > 0) {
      setRawPreview(JSON.stringify(jilFiles[activeIndex], null, 2));
    }
  }, [jilFiles, activeIndex]);

  return (
    <div className="jileditor-livePreview">
      <h5>Live JSON Preview</h5>
      <textarea className="jileditor-textarea" value={rawPreview} readOnly />
    </div>
  );
}


---

Summary

Phase 3 – Action Handlers:

jilActions.js: Contains functions for handling field changes, adding optional properties, array items, removing items, replacing data, and downloading the JSON.


Phase 4 – File Navigation & Live Preview:

JilFileNavigation.jsx: Provides navigation (Prev/Next) and an “Add New File” button to switch between multiple JIL files.

JilLivePreview.jsx: Displays a live JSON preview of the currently active JIL file.



Remember that the API calls (when implemented) should include your generateSearchHeader in the headers. For now, these files mock the API behavior.

This complete set of files (Phases 3 and 4) should integrate with your Phase 1 and Phase 2 files to form the full frontend for the dynamic JIL editor. Let me know if you need further details or adjustments!

