Below is a complete solution that includes:

1. A new backend endpoint (getPropertiesFileOrTemplate) that checks for an updated file by requirement ID. If found, it returns that; otherwise, it falls back to the default template.


2. Updated frontend code (4 files) that:

Uses =…,\ in the live preview only (appending ,\ at the end of each value in the preview).

Strips any trailing ,\ when parsing the data back into the editable fields.

Shows a small button with a cross for removal.

Has larger width for key/value inputs.

Places the “Generate Properties File” button below the two-column layout.




Feel free to adapt the naming conventions and references (e.g., PropertiesController, JSONTemplateRepository) to match your existing code.


---

1. Backend: New Endpoint

Below is a pseudo-code snippet you can add to your existing controller (e.g., ApplicationAuthorizerController or a new PropertiesController). It uses a repository method that returns a List<PropertiesFile> by requirement ID. If the list is not empty, we return the first updated file; otherwise, we fall back to the default template.

@RestController
@RequestMapping("/api/v1")
public class PropertiesController {

    @Autowired
    private PropertiesFileRepository propertiesFileRepository;

    @Autowired
    private JSONTemplateRepository jsonTemplateRepository; 
    // Or a service that fetches your default template

    @GetMapping("/getPropertiesFileOrTemplate/{requirementId}")
    public ResponseEntity<?> getPropertiesFileOrTemplate(@PathVariable("requirementId") String requirementId) {
        // 1) Check if a user-updated file exists in your "PropertiesFile_Dev" collection
        List<PropertiesFile> updatedFiles = propertiesFileRepository.findByRequirementId(requirementId);
        if (!updatedFiles.isEmpty()) {
            // Return the first matching updated file
            return ResponseEntity.ok(updatedFiles.get(0));
        } else {
            // 2) If no updated file => fetch the default template
            String templateName = "COMPMPROP"; // or whichever template name you use
            Optional<JSONTemplate> defaultTemplateOpt = jsonTemplateRepository.findByTemplateName(templateName);
            if (defaultTemplateOpt.isPresent()) {
                return ResponseEntity.ok(defaultTemplateOpt.get());
            } else {
                // 3) If even the default is missing, respond with 404
                return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body("No updated file or default template found for requirementId: " + requirementId);
            }
        }
    }
}

Repository Example (if returning a List):

@Repository
public interface PropertiesFileRepository extends MongoRepository<PropertiesFile, String> {
    List<PropertiesFile> findByRequirementId(String requirementId);
}

With this endpoint in place, your frontend can call:

GET /api/v1/getPropertiesFileOrTemplate/{requirementId}

and automatically receive the updated file if it exists, or the default template otherwise.


---

2. Frontend Code (4 Files)

Below is fully updated code that:

Fetches from the new endpoint (/getPropertiesFileOrTemplate/{requirementId}) instead of always getting the default template.

Appends ,\ to each value in the preview only.

Strips ,\ when parsing back into the editor fields, so the user doesn’t see those extra characters in the text fields.

Displays a small cross button for removal.

Places the “Generate Properties File” button below the two-column layout.


2.1 propertiesActions.js

// propertiesActions.js
import axios from "axios";
import { MICROSERVICE_URL } from "../../../constant";
import { generateSearchHeader } from "../../../Authentication";

/**
 * GET the updated file or default template for a requirement
 * Endpoint: /api/v1/getPropertiesFileOrTemplate/{requirementId}
 */
export async function getPropertiesFileOrTemplate(requirementId, appGlobalState) {
  const response = await axios.get(
    `${MICROSERVICE_URL}/api/v1/getPropertiesFileOrTemplate/${requirementId}`,
    {
      headers: generateSearchHeader(appGlobalState),
    }
  );
  // If not 200, 201, or if error, handle accordingly
  if (response.status !== 200 && response.status !== 201) {
    throw new Error(`Failed to fetch properties: ${response.status}`);
  }
  // Return the data (which could be the updated file or the default template)
  return response.data;
}

/**
 * POST to create (or update) the properties file
 * Endpoint: /api/v1/createCMPPropFile
 */
export async function createCMPPropFile(requirement, appGlobalState) {
  const response = await fetch(`${MICROSERVICE_URL}/api/v1/createCMPPropFile`, {
    method: "POST",
    headers: generateSearchHeader(appGlobalState),
    body: JSON.stringify(requirement),
  });
  return response.json();
}

> Note: We removed references to the old getPropertiesTemplate or getRequirementDetails if you no longer need them. If you still need to fetch the requirement details from another endpoint, you can keep that logic.




---

2.2 PropertiesEditor.jsx

// PropertiesEditor.jsx
import React, { useEffect, useState, useMemo } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import { useAppGlobalState } from "@wf/react-library";
import { MICROSERVICE_URL } from "../../../constant";
import { generateSearchHeader } from "../../../Authentication";
import IngressNavigation from "../../Workflow/IngressNavigation";
import DiaasButton from "../../../components/DiaasButton";
import "./PropertiesEditor.css";
import { getPropertiesFileOrTemplate, createCMPPropFile } from "./propertiesActions";
import KeyValuePair from "./KeyValuePair";

/**
 * We append ",\" to each value in the preview only.
 * In parse, we strip trailing ",\" so the user doesn't see it in the editor fields.
 */
function parsePropertiesString(str) {
  if (!str) return [];
  const lines = str.split("\n");
  return lines.map((line) => {
    const equalIndex = line.indexOf("=");
    let key = "";
    let value = "";
    if (equalIndex !== -1) {
      key = line.slice(0, equalIndex).trim();
      value = line.slice(equalIndex + 1).trim();
    } else {
      // No "=" found
      key = line.trim();
      value = "";
    }
    // Remove trailing ",\" if present
    if (value.endsWith(",\\")) {
      value = value.slice(0, -2).trim();
    }
    return { key, value };
  });
}

/**
 * Convert array of {key, value} to a properties string,
 * appending ",\" to each value in the preview only.
 */
function propertiesArrayToString(pairs) {
  return pairs
    .map(({ key, value }) => {
      // If there's a value, append ",\"
      const finalValue = value ? `${value},\\` : value;
      return `${key}=${finalValue}`;
    })
    .join("\n");
}

export default function PropertiesEditor() {
  const appGlobalState = useAppGlobalState();
  const [pairs, setPairs] = useState([]); // array of { key, value }
  const [requirementId, setRequirementId] = useState("");
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [previewText, setPreviewText] = useState("");

  const location = useLocation();
  const navigate = useNavigate();

  // Memoize location.state so we don't re-trigger effect constantly
  const stableLocationState = useMemo(() => location.state, [location.state]);

  useEffect(() => {
    const fetchData = async () => {
      try {
        // 1) Use the new endpoint to get updated or default properties
        const result = await getPropertiesFileOrTemplate(stableLocationState, appGlobalState);
        /**
         * result might look like:
         * {
         *   "requirementId": "JIRA-123",
         *   "json": "key1=value1\nkey2=value2"
         * }
         * or if it's a default template, might be something else like:
         * { "templateObjList": [ { "json": ... } ] }  -> depends on how your backend returns it
         *
         * Adjust parsing accordingly.
         */
        // For simplicity, let's assume the returned object has a "json" field with the properties
        if (!result.json) {
          throw new Error("No 'json' field found in response");
        }
        setRequirementId(result.requirementId || stableLocationState);
        // parse the properties
        const parsedPairs = parsePropertiesString(result.json);
        setPairs(parsedPairs);
      } catch (err) {
        setError(err);
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [stableLocationState, appGlobalState]);

  // Whenever pairs changes, update preview
  useEffect(() => {
    const preview = propertiesArrayToString(pairs);
    setPreviewText(preview);
  }, [pairs]);

  // Handlers for editing pairs
  const handlePairChange = (index, newPair) => {
    const updated = [...pairs];
    updated[index] = newPair;
    setPairs(updated);
  };

  const handleRemovePair = (index) => {
    setPairs(pairs.filter((_, i) => i !== index));
  };

  const handleAddPair = () => {
    setPairs([...pairs, { key: "", value: "" }]);
  };

  // Generate/Save properties file
  const handleSubmit = async () => {
    // Convert pairs to final string
    const finalString = propertiesArrayToString(pairs);
    // Build request body
    const requirement = {
      requirementId,
      // The backend might expect a field named "json" or "parameters"
      // depending on your existing logic. Adjust accordingly.
      json: finalString,
      fileName: "PropertiesFile_" + requirementId, // or whatever naming logic
    };
    try {
      const response = await createCMPPropFile(requirement, appGlobalState);
      console.log("Create response:", response);
      if (response && response.statusCode === 201) {
        alert("Properties File created successfully!");
        navigate("/createdcmpjil", { state: requirementId });
      } else {
        const code = response ? response.statusCode : "undefined";
        alert("Errorcode:" + code + " - Creation failed!");
      }
    } catch (err) {
      console.error("Error creating properties file:", err);
      alert("Error: " + err.message);
    }
  };

  if (loading) return <div>Loading...</div>;
  if (error) return <div style={{ color: "red" }}>Error: {error.message}</div>;

  return (
    <div className="applicationContainer">
      <IngressNavigation />
      <h5>Properties File Configuration</h5>
      <div className="editor-container">
        {/* Left panel: key-value pairs */}
        <div className="editor-left">
          <h6>Edit Key-Value Pairs</h6>
          <div className="pairs-scroll">
            {pairs.map((pair, idx) => (
              <KeyValuePair
                key={idx}
                index={idx}
                pair={pair}
                onChange={handlePairChange}
                onRemove={handleRemovePair}
              />
            ))}
          </div>
          <button onClick={handleAddPair} className="add-button">
            Add New Pair
          </button>
        </div>

        {/* Right panel: live preview */}
        <div className="editor-right">
          <h6>Live Preview</h6>
          <div className="preview-scroll">
            <textarea
              readOnly
              value={previewText}
              className="preview-textarea"
            />
          </div>
        </div>
      </div>

      {/* Generate button placed below the two-column layout */}
      <div className="generate-button-container">
        <DiaasButton title="Generate Properties File" handleChange={handleSubmit} />
      </div>
    </div>
  );
}

> Important:

The exact JSON structure returned by getPropertiesFileOrTemplate might differ from the snippet above. Adjust how you extract result.json or result.requirementId to match your actual response structure.

If your backend uses parameters instead of json, or another field name, update accordingly.





---

2.3 KeyValuePair.jsx

// KeyValuePair.jsx
import React from "react";
import PropTypes from "prop-types";
import "./PropertiesEditor.css";

export default function KeyValuePair({ index, pair, onChange, onRemove }) {
  const handleKeyChange = (e) => {
    onChange(index, { ...pair, key: e.target.value });
  };

  const handleValueChange = (e) => {
    onChange(index, { ...pair, value: e.target.value });
  };

  return (
    <div className="pair-row">
      <input
        type="text"
        placeholder="Key"
        value={pair.key}
        onChange={handleKeyChange}
        className="pair-input"
      />
      <span className="colon-separator">=</span>
      <input
        type="text"
        placeholder="Value"
        value={pair.value}
        onChange={handleValueChange}
        className="pair-input"
      />
      <button onClick={() => onRemove(index)} className="remove-button">
        ×
      </button>
    </div>
  );
}

KeyValuePair.propTypes = {
  index: PropTypes.number.isRequired,
  pair: PropTypes.shape({
    key: PropTypes.string,
    value: PropTypes.string,
  }).isRequired,
  onChange: PropTypes.func.isRequired,
  onRemove: PropTypes.func.isRequired,
};


---

2.4 PropertiesEditor.css

/* PropertiesEditor.css */

.applicationContainer {
  max-width: 900px;
  margin: 0 auto;
  padding: 20px;
  font-family: Arial, sans-serif;
}

.editor-container {
  display: flex;
  gap: 20px;
  margin-top: 20px;
}

/* Left panel styling */
.editor-left {
  flex: 1;
  border: 1px solid #ccc;
  padding: 15px;
  border-radius: 5px;
  height: 500px;
  overflow-y: auto;
}

.editor-right {
  flex: 1;
  border: 1px solid #ccc;
  padding: 15px;
  border-radius: 5px;
  height: 500px;
  overflow-y: auto;
}

.pair-row {
  display: flex;
  align-items: center;
  margin-bottom: 8px;
}

/* Double the width of key-value input boxes */
.pair-input {
  padding: 8px;
  margin-right: 8px;
  flex: 1;
  min-width: 300px;
}

.colon-separator {
  margin-right: 8px;
}

/* Small cross button for removal */
.remove-button {
  background-color: transparent;
  color: red;
  border: none;
  font-size: 18px;
  cursor: pointer;
  padding: 2px 6px;
}

.remove-button:hover {
  color: darkred;
}

.add-button {
  margin-top: 10px;
  padding: 8px 12px;
  cursor: pointer;
}

.generate-button-container {
  display: flex;
  justify-content: center;
  margin-top: 20px;
}

.preview-textarea {
  width: 100%;
  height: 100%;
  padding: 10px;
  font-family: monospace;
  border: 1px solid #ccc;
  border-radius: 5px;
  resize: none;
}

.pairs-scroll {
  height: 100%;
  overflow-y: auto;
}

.preview-scroll {
  height: 100%;
  overflow-y: auto;
}


---

How It All Works

1. Backend

getPropertiesFileOrTemplate/{requirementId} checks if there’s a row in your “PropertiesFile_Dev” (or whichever) collection for that requirement. If yes, returns it; if no, returns the default.

The returned object should have a .json or .parameters field containing the actual properties text.



2. Frontend

PropertiesEditor.jsx calls the new endpoint.

It parses the returned .json text, removing any trailing ,\ so the user sees a clean value.

The live preview appends ,\ to each value.

The user can add or remove pairs, then click Generate to save.

createCMPPropFile is called, sending the final string (with ,\ in each value) to the backend.



3. UI

Two columns: left for pairs, right for preview. Each scrolls if content exceeds 500px.

The remove button is a small cross, and the key/value inputs have been widened.





---

Final Thoughts

Adjust the .json or .parameters property names to match what your backend expects.

If you still need to fetch requirement details (like tableName) from a separate endpoint, you can keep or combine that logic.

Test both scenarios:

1. A requirement that already has an updated file in MongoDB.


2. A requirement with no updated file (should fall back to default).




This setup satisfies all your stated requirements:

1. New endpoint returning either updated or default.


2. Extra characters (,\) only in preview.


3. Cross button for removal.


4. Wider key-value input fields.


5. Scroll in each panel and the generate button below.



Feel free to tweak any naming or minor details as needed!

