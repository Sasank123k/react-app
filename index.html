// ----- Tests for Remaining Functions -----

import com.fasterxml.jackson.databind.JsonNode;
import com.wellsfargo.utcap.dto.BuildDetailsDTO;
import com.wellsfargo.utcap.exception.GlobalRuntimeException;
import com.wellsfargo.utcap.exception.JenkinsApiException;
import com.wellsfargo.utcap.model.BuildDetails;
import com.wellsfargo.utcap.model.BuildDetailsRepoLevel;
import com.wellsfargo.utcap.model.BuildRequest;
import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.protocol.HttpClientContext;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.HttpHost;
import org.apache.http.util.EntityUtils;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.net.URI;
import java.util.*;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.any(URI.class);

// ----------- getCrumb() Test --------------
@Test
public void testGetCrumb_success() throws Exception {
    // Set jenkinsUrl (assumed already injected in setup)
    // Setup a dummy crumb JSON response.
    String expectedCrumbResponse = "{\"crumbRequestField\":\"Jenkins-Crumb\",\"crumb\":\"abc123\"}";
    
    // Create dummy HTTP client and response.
    CloseableHttpClient dummyClient = Mockito.mock(CloseableHttpClient.class);
    CloseableHttpResponse dummyResponse = Mockito.mock(CloseableHttpResponse.class);
    HttpEntity dummyEntity = Mockito.mock(HttpEntity.class);
    
    Mockito.when(dummyResponse.getEntity()).thenReturn(dummyEntity);
    Mockito.when(dummyEntity.getContent()).thenReturn(new ByteArrayInputStream(expectedCrumbResponse.getBytes()));
    Mockito.when(dummyClient.execute(any(HttpHost.class), any(HttpGet.class), any(HttpClientContext.class)))
           .thenReturn(dummyResponse);
    
    // Use our helper to create a dummy context.
    Object dummyCtx = createDummyHttpClientWithContext(dummyClient);
    Mockito.doReturn(dummyCtx).when(jenkinsClient).createHttpClientWithContext(any(URI.class));
    
    // Call getCrumb().
    String actualCrumbResponse = jenkinsClient.getCrumb();
    assertEquals(expectedCrumbResponse, actualCrumbResponse);
    
    Mockito.verify(dummyClient).close();
}

// ----------- triggerBuildAndGetBuildDetails() Tests --------------

// Success flow: override internal methods to simulate a complete, successful build trigger.
@Test
public void testTriggerBuildAndGetBuildDetails_success() throws Exception {
    // Override getLatestBuildNumber to return baseline (100)
    Mockito.doReturn(100).when(jenkinsClient).getLatestBuildNumber("owner", "repo", "branch");
    
    // Override getCrumb to return valid crumb JSON.
    String crumbJson = "{\"crumbRequestField\":\"Jenkins-Crumb\",\"crumb\":\"abc123\"}";
    Mockito.doReturn(crumbJson).when(jenkinsClient).getCrumb();
    
    // Override pollForNewBuild to return new build number (101)
    Mockito.doReturn(101).when(jenkinsClient).pollForNewBuild("owner", "repo", "branch", 100);
    
    // Override getstageDetails to return a dummy JSON node with a display name.
    String stageJson = "{\"name\":\"Build-101\"}";
    JsonNode stageNode = objectMapper.readTree(stageJson);
    Mockito.doReturn(stageNode).when(jenkinsClient).getstageDetails("owner", "repo", "branch", 101);
    
    // Setup repository: return a BuildRequest with one BuildDetailsRepoLevel matching the parameters.
    BuildDetailsRepoLevel repoLevel = new BuildDetailsRepoLevel("owner", "repo", "branch", Collections.emptyList());
    BuildRequest buildRequest = new BuildRequest("req1", Arrays.asList(repoLevel));
    Mockito.when(buildRequestRepository.findById("req1")).thenReturn(Optional.of(buildRequest));
    
    // Call the method.
    BuildDetailsDTO result = jenkinsClient.triggerBuildAndGetBuildDetails("req1", "owner", "repo", "branch", Collections.emptyList());
    
    // Validate result.
    assertEquals(101, result.getBuildNumber());
    assertEquals("Build-101", result.getDisplayName());
    
    // Validate that repository's BuildDetailsRepoLevel got updated.
    assertEquals(101, repoLevel.getLastBuildNumber().intValue());
    assertEquals("Build-101", repoLevel.getLastDisplayName());
    Mockito.verify(buildRequestRepository).save(buildRequest);
}

// Test triggerBuildAndGetBuildDetails when an IOException occurs (simulate via getCrumb throwing IOException)
@Test
public void testTriggerBuildAndGetBuildDetails_ioException() throws Exception {
    // Simulate getCrumb() throwing an IOException.
    Mockito.doThrow(new IOException("I/O error")).when(jenkinsClient).getCrumb();
    
    JenkinsApiException exception = assertThrows(JenkinsApiException.class, () ->
          jenkinsClient.triggerBuildAndGetBuildDetails("req1", "owner", "repo", "branch", Collections.emptyList()));
    assertTrue(exception.getMessage().contains("I/O error"));
}

// ----------- getUpdatedBuildRequest() Tests --------------

// Success flow: repository returns a BuildRequest and getBuildDetails and getstageDetails provide valid data.
@Test
public void testGetUpdatedBuildRequest_success() throws Exception {
    // Create a BuildRequest with one BuildDetailsRepoLevel.
    BuildDetailsRepoLevel repoLevel = new BuildDetailsRepoLevel("owner", "repo", "branch", Collections.emptyList());
    BuildRequest buildRequest = new BuildRequest("req1", Arrays.asList(repoLevel));
    Mockito.when(buildRequestRepository.findById("req1")).thenReturn(Optional.of(buildRequest));
    
    // Override getBuildDetails to return a list with one BuildDetails.
    BuildDetails dummyBuildDetail = new BuildDetails(50, "Build-50", "SUCCESS");
    List<BuildDetails> buildDetailsList = Arrays.asList(dummyBuildDetail);
    Mockito.doReturn(buildDetailsList).when(jenkinsClient).getBuildDetails("owner", "repo", "branch");
    
    // Override getstageDetails to return a stage JSON that helps update the repo level.
    // For instance, the JSON contains "name": "MyDisplay", "status": "SUCCESS", 
    // and a stages array with a DevDeploy stage as SUCCESS and QADeploy as FAILED.
    String stageJson = "{ \"name\": \"MyDisplay\", \"status\": \"SUCCESS\", \"stages\": [ " +
                       "{ \"name\": \"DevDeploy\", \"status\": \"SUCCESS\" }, { \"name\": \"QADeploy\", \"status\": \"FAILED\" } ] }";
    JsonNode stageNode = objectMapper.readTree(stageJson);
    Mockito.doReturn(stageNode).when(jenkinsClient).getstageDetails("owner", "repo", "branch", 50);
    
    // Call getUpdatedBuildRequest.
    BuildRequest updatedRequest = jenkinsClient.getUpdatedBuildRequest("req1");
    
    // Validate that the BuildDetailsRepoLevel is updated.
    BuildDetailsRepoLevel updatedRepoLevel = updatedRequest.getBuildDetails().get(0);
    assertEquals(50, updatedRepoLevel.getLastBuildNumber().intValue());
    assertEquals("MyDisplay", updatedRepoLevel.getLastDisplayName());
    // As per helperDeployStatus logic, DevDeploy with SUCCESS returns "Y", QADeploy returns "N".
    assertEquals("Y", updatedRepoLevel.getIsDevDeployed());
    assertEquals("N", updatedRepoLevel.getIsQaDeployed());
    assertEquals("SUCCESS", updatedRepoLevel.getLastOverallStatus());
    
    Mockito.verify(buildRequestRepository).save(buildRequest);
}

// Test getUpdatedBuildRequest when the repository returns an empty Optional.
@Test
public void testGetUpdatedBuildRequest_notFound() {
    Mockito.when(buildRequestRepository.findById("req-not-found")).thenReturn(Optional.empty());
    GlobalRuntimeException exception = assertThrows(GlobalRuntimeException.class, () ->
        jenkinsClient.getUpdatedBuildRequest("req-not-found"));
    assertTrue(exception.getMessage().contains("No build request found for requirement ID: req-not-found"));
}
