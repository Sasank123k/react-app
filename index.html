aBelow are the updated versions of JILEditorContainer.jsx and JILEditor.jsx with additional guarding and robust checks to ensure that metadata and its definitions are available before any dependent logic runs. This should eliminate the “definitions not found” error on initial load while still using asynchronous calls and a loading spinner.


---

JILEditorContainer.jsx

In this update, we check explicitly that metadata is loaded before rendering the editor. We also use a ternary expression (instead of a bare else) to avoid violating Sonar rules.

import React, { useState, useEffect } from "react";
import PropTypes from "prop-types";
import JILEditor from "./JILEditor";
import JILNavigation from "./JILNavigation";
import { JILEditorProvider } from "./JILEditorContext";
import { MICROSERVICE_URL } from "../../../util/Constant";
import { generateSearHeader } from "../../../Authentication";
import { useAppGlobalState } from "@wf/react-library";
import { createDefaultJILFile, normalizeJobData } from "./JILUtils";
import "./JILEditor.css";

const JILEditorContainer = ({ requirementId, flow = "EDL" }) => {
  const [jilFiles, setJilFiles] = useState([]);
  const [metadata, setMetadata] = useState(null);
  const [loading, setLoading] = useState(true);
  const [currentFileIndex, setCurrentFileIndex] = useState(0);
  const globalState = useAppGlobalState();

  const fileConfig =
    flow === "INGRESS"
      ? { count: 2, names: ["INGRESS_JIL_1", "INGRESS_JIL_2"] }
      : { count: 1, names: ["EDL_JIL"] };

  // Fetch metadata from the backend
  useEffect(() => {
    fetch(`${MICROSERVICE_URL}/api/jilMetadata`, {
      method: "GET",
      headers: generateSearHeader(globalState)
    })
      .then((res) => res.json())
      .then((data) => {
        if (data && data.length > 0 && data[0].metaData) {
          setMetadata(data[0].metaData);
        }
      })
      .catch((err) => {
        console.error("Error fetching metadata:", err);
      });
  }, [globalState]);

  // Fetch JIL file data and normalize, but only when metadata is available
  useEffect(() => {
    if (!metadata || !metadata.definitions) return; // wait until metadata is loaded
    fetch(`${MICROSERVICE_URL}/api/jilData/${requirementId}`, {
      method: "GET",
      headers: generateSearHeader(globalState)
    })
      .then((res) => res.json())
      .then((data) => {
        const files =
          data.jilFiles && data.jilFiles.length > 0
            ? data.jilFiles.map((file) =>
                file.jsonData && file.jsonData.mainBox
                  ? {
                      ...file,
                      jsonData: {
                        ...file.jsonData,
                        mainBox: normalizeJobData(
                          file.jsonData.mainBox,
                          metadata.definitions.MainBOX,
                          metadata.definitions
                        )
                      }
                    }
                  : file
              )
            : Array.from({ length: fileConfig.count }, () =>
                createDefaultJILFile(metadata.definitions)
              );
        setJilFiles(files);
        setLoading(false);
      })
      .catch((err) => {
        console.error("Error fetching JIL data:", err);
        setLoading(false);
      });
  }, [requirementId, globalState, metadata, fileConfig.count]);

  if (loading || !metadata || !metadata.definitions) {
    return <div>Loading...</div>;
  }

  const contextValue = {
    jilFiles,
    setJilFiles,
    currentFileIndex,
    setCurrentFileIndex,
    metadata,
    fileNames: fileConfig.names
  };

  return (
    <JILEditorProvider value={contextValue}>
      <div className="jil-editor-container">
        <JILNavigation />
        <JILEditor requirementId={requirementId} />
      </div>
    </JILEditorProvider>
  );
};

JILEditorContainer.propTypes = {
  requirementId: PropTypes.string.isRequired,
  flow: PropTypes.string
};

export default JILEditorContainer;


---

JILEditor.jsx

This file now includes an extracted, flat recursive validation function and checks metadata availability before using metadata.definitions in the effect. The save handler is refactored to use early returns to reduce nesting and cognitive complexity.

import React, { useState, useEffect, useContext } from "react";
import PropTypes from "prop-types";
import { JILEditorContext } from "./JILEditorContext";
import JILFieldRenderer from "./JILFieldRenderer";
import { MICROSERVICE_URL } from "../../../util/Constant";
import { generateSearHeader } from "../../../Authentication";
import { useAppGlobalState } from "@wf/react-library";
import { convertToJILText } from "./JILUtils";
import "./JILEditor.css";

// Recursive validation utility moved to top-level to avoid deep nesting
const validateJobData = (data) => {
  if (typeof data !== "object" || data === null) {
    return data !== "";
  }
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      if (key === "properties" && Array.isArray(data[key])) {
        for (const child of data[key]) {
          if (!validateJobData(child)) return false;
        }
      } else if (typeof data[key] === "object") {
        if (!validateJobData(data[key])) return false;
      } else if (data[key] === "") {
        return false;
      }
    }
  }
  return true;
};

const JILEditor = ({ requirementId }) => {
  const { jilFiles, currentFileIndex, setJilFiles, metadata, fileNames } = useContext(JILEditorContext);
  const [rawPreview, setRawPreview] = useState("");
  const globalState = useAppGlobalState();
  const currentFile = jilFiles[currentFileIndex];

  // Guard effect: run only if metadata and definitions exist
  useEffect(() => {
    if (metadata && metadata.definitions && currentFile && currentFile.jsonData) {
      setRawPreview(convertToJILText(currentFile.jsonData, metadata.definitions));
    }
  }, [JSON.stringify(currentFile), metadata]);

  const handleSave = () => {
    // Validate each file's JSON data
    if (jilFiles.some((file) => !validateJobData(file.jsonData))) {
      alert("All fields are mandatory. Please fill in every field before saving.");
      return;
    }
    const payload = {
      jilFiles: jilFiles.map((file, idx) => ({
        fileName: fileNames[idx] || `File_${idx + 1}`,
        jsonData: file.jsonData,
        content: convertToJILText(file.jsonData, metadata.definitions)
      }))
    };

    fetch(`${MICROSERVICE_URL}/api/jilData/${requirementId}`, {
      method: "PUT",
      headers: {
        ...generateSearHeader(globalState),
        "Content-Type": "application/json"
      },
      body: JSON.stringify(payload)
    })
      .then((res) => {
        if (!res.ok) {
          throw new Error("Save failed");
        }
        return res.json();
      })
      .then(() => {
        alert("JIL file saved successfully!");
      })
      .catch((err) => {
        console.error("Error saving JIL file:", err);
      });
  };

  if (!metadata || !metadata.definitions) {
    return <div>Loading metadata...</div>;
  }

  return (
    <div className="jil-editor">
      <div className="jil-editor-header">
        <button onClick={handleSave}>Save</button>
      </div>
      <div className="jil-editor-body">
        <div className="jil-editor-left scroll-container">
          <h4>Structured Editor</h4>
          <div className="scroll-content">
            <JILFieldRenderer
              schema={metadata.definitions.MainBOX}
              definitions={metadata.definitions}
              data={currentFile.jsonData.mainBox || {}}
              path={["mainBox"]}
              onFieldChange={(updatedData) => {
                const newFiles = [...jilFiles];
                newFiles[currentFileIndex].jsonData.mainBox = updatedData;
                setJilFiles(newFiles);
              }}
              onRemoveJob={null} // Not needed at this level
            />
          </div>
        </div>
        <div className="jil-editor-right scroll-container">
          <h4>Live Preview</h4>
          <textarea readOnly value={rawPreview} />
        </div>
      </div>
    </div>
  );
};

JILEditor.propTypes = {
  requirementId: PropTypes.string.isRequired
};

export default JILEditor;


---

Explanation

Guard Clauses:
Both files now explicitly check that metadata and metadata.definitions exist before attempting to use them. In JILEditor.jsx, the useEffect that generates the preview only runs if these values exist.

Flattened Complexity:
The recursive validateJobData function is extracted outside of the main component scope, and early returns are used in the handleSave function to reduce nesting.

Loading State:
Both files ensure that if the metadata isn’t available yet, the UI shows “Loading…” instead of throwing an error.


These updates should make the code more robust and eliminate the error that initially appears when the page is loaded. Let me know if you need any further modifications or clarifications.

